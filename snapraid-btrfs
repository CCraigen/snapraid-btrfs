#!/bin/bash -

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

set -eEuo pipefail
shopt -s extglob

readonly EXIT_INTERNAL_ERROR=64
readonly EXIT_INVALID_ARGUMENT=65
readonly EXIT_INVALID_CONFIG=66
readonly EXIT_NO_PERMISSIONS=67
readonly EXIT_SNAPSHOT_NOT_FOUND=68
readonly EXIT_INTERACTIVE_NO=69

# Apply the --pre-post and --no-pre-post command line options
apply_pre_post_options() {
    local i j
    if [[ "${#pre_post_option[@]}" -gt 0 ]] ; then
        for i in "${pre_post_option[@]}" ; do
            config_must_exist "$i"
        done
        pre_post_configs=( "${pre_post_option[@]}" )
    else
        pre_post_configs=( "${snapper_configs[@]}" )
    fi
    if [[ "${#no_pre_post_option[@]}" -gt 0 ]] ; then
        local -a temp_array
        for i in "${no_pre_post_option[@]}" ; do
            config_must_exist "$i"
            temp_array=()
            for j in "${pre_post_configs[@]}" ; do
                [[ "$j" = "$i" ]] || temp_array+=( "$j" )
            done
            pre_post_configs=( "${temp_array[@]}" )
        done
    fi
}

# Set use_snapshot from comma-separated key=value pairs specified in $1
apply_use_snapshot_option() {
    local -a args
    local config config_using i
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        config=
        config_using=
        IFS='=' read -r config config_using <<< "$i"
        config_must_exist "$config"
        use_snapshot[$config]="$config_using"
    done
}

# Sanity check snapper configuration
check_config() {
    # Make sure we found some configs
    if [[ "${#snapper_configs[@]}" -eq 0 ]] ; then
        printf '%s: No snapper configs found for any data drives ' "$0" >&2
        printf 'in snapraid config file\n' >&2
        exit $EXIT_INVALID_CONFIG
    fi
    # We don't want to snapshot the content files. So, check the directories of
    # the content files, and compare their mount points with those of the
    # subvolumes we are snapshotting, to see if any match
    local f1 f2 content_{dir,mount} i
    while IFS=$' \t' read -r f1 f2 ; do
        if [[ "$f1" = content ]] ; then
            content_dir="$(dirname "$f2")"
            content_mount="$(stat --format=%m "$content_dir")"
            for i in "${snapper_configs[@]}" ; do
                if [[ "$content_mount" -ef "${snapper_subvols[$i]}" ]] ; then
                    printf '%s: Content file %s found in data subvolume %s - ' \
                           "$0" "$f2" "${snapper_subvols[$i]}" >&2
                    printf 'create a dedicated subvolume for the content ' >&2
                    printf 'file and try again.\n' >&2
                    exit $EXIT_INVALID_CONFIG
                fi
            done
        fi
    done < "$config_file"
    # Check to make sure the user has permission to access snapshots
    for i in "${snapper_configs[@]}" ; do
        # Try a snapper ls first, in case SYNC_ACL has just been set
	if ! { "$my_snapper" -c "$i" ls > /dev/null &&
		   [[ -r "${snapper_subvols[$i]}/.snapshots" ]] ; }
	then
           printf '%s: Could not read %s - is SYNC_ACL set?\n' "$0" \
                  "${snapper_subvols[$i]}/.snapshots" >&2
           exit $EXIT_NO_PERMISSIONS
        fi
    done
}

# Make sure all external binaries we need can be found in $PATH
# doesn't include those only used if -x option is enabled
check_dependencies() {
    local deps=( "$my_snapraid" "$my_snapper"
                 awk dirname grep sed stat tail tr )
    local i
    for i in "${deps[@]}" ; do
        if ! type "$i" &> /dev/null ; then
            # shellcheck disable=SC2016
            printf '%s: Could not find %s in $PATH\n' "$0" "$i" >&2
            exit $EXIT_INTERNAL_ERROR
        fi
    done
}

# Make sure the user hasn't tried to pass through the -c option to snapraid
check_snapraid_arguments() {
    while [[ $# -gt 0 ]] ; do
        case $1 in
            -c|--conf)
                printf '%s: The -c option may not be passed through - ' "$0" >&2
                printf 'place the -c option before the command instead.\n' >&2
                printf 'Use %s --help for help.\n' "$0" >&2
                exit $EXIT_INVALID_ARGUMENT ;;
            # snapraid options that take arguments, meaning we should shift 2
            --@(filter?(-disk)|import|plan|older-than|log|start|count)) ;&
            --@(error-limit|gen-conf)) ;&
            -[fdipolSBLC])
                shift 2 || shift ;;
            *)
                shift ;;
        esac
    done
}

# In each config, delete snapshots with userdata key snapraid-btrfs created
# before use_snapshot[$i], or all such snapshots if use_snapshot[$i]=0
cleanup_snapshots() {
    local ret=0 snapper_ret snaps_to_consider i j
    local -a snapper_cmd
    for i in "${snapper_configs[@]}" ; do
        [[ -z "${use_snapshot[$i]}" ]] && break
        snaps_to_consider="$("$my_snapper" -c "$i" ls |
            parse_snapper_ls snapraid-btrfs)"
        for j in $snaps_to_consider ; do
            if [[ "${use_snapshot[$i]}" -eq 0 ]] ||
                   [[ "${use_snapshot[$i]}" -gt "$j" ]]
            then
                snapper_cmd=( "$my_snapper" -c "$i" rm "$j" )
                if [[ "${interactive:-}" ]] ; then
                    interactive_ask "${snapper_cmd[@]}" >&2
                elif [[ $verbose -ge 1 ]] ; then
                    printf '%s ' "${snapper_cmd[@]}"
                    printf '\n'
                fi
                "${snapper_cmd[@]}" && true
                snapper_ret=$?
                [[ $snapper_ret -eq 0 ]] || ret=$snapper_ret
            fi
        done
    done
    return $ret
}

# Check that the user didn't specify a nonexistent snapper config by ensuring
# that a subvolume is set for the config name
config_must_exist() {
    if ! [[ "${snapper_subvols[$1]:-}" ]] ; then
        printf '%s: Invalid snapper configuration %s!\n' "$0" "$1" >&2
        exit $EXIT_INVALID_ARGUMENT
    fi
}

# Calling once creates pre snapshots, calling again creates corresponding post
create_pre_post_snapshots() {
    local -a snapper_cmd
    local i
    for i in "${pre_post_configs[@]}" ; do
        snapper_cmd=( "$my_snapper" -c "$i" create )
        [[ "${snapper_cleanup:-}" ]] &&
            snapper_cmd+=( -c "$snapper_cleanup" )
        snapper_cmd+=( -u "$snapper_userdata" )
        # Check if we've already done a pre snapshot
        if [[ "${pre_snapshots[$i]:-}" ]] ; then
            # We've already done pre snapshots, so create corresponding post
            if [[ "${snapper_description:-}" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "snapraid-btrfs post-$1" )
            fi
            snapper_cmd+=( -t post --pre-number "${pre_snapshots[$i]}" )
            "${snapper_cmd[@]}" || true
        else
            # We haven't created pre snapshots yet, so create them and store the
            # snapshot numbers from snapper -p option in ${pre_snapshots[@]}
            if [[ "${snapper_description:-}" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "snapraid-btrfs pre-$1" )
            fi
            snapper_cmd+=( -t pre -p )
            pre_snapshots[$i]="$("${snapper_cmd[@]}")"
        fi
    done
}

err_trap() {
    printf '%s: %s: %s failed with exit status %s\n' "$0" "$1" \
           "$BASH_COMMAND" "$2" >&2
    printf 'Traceback:\n' >&2
    local i=0
    while caller "$i" ; do ((++i)) ; done
    exit "$2"
}

# Replace literal \t and \r characters in stderr with escapes
# used when -x is specified to avoid clobbering output with \r
# Literal \t and \r sequences are not replaced by \\t and \\r in order to
# preserve readability - ambiguity should be minimal
escape_stderr() {
    local sed_escape_pipe
    sed_escape_pipe="$(mktemp -u)"
    mkfifo -- "$sed_escape_pipe"
    # Keep pipe open indefinitely
    tail -f /dev/null > "$sed_escape_pipe" &
    # shellcheck disable=SC2064
    trap "kill -TERM $!" EXIT
    sed -e $'s/\r/\\\\r/g' -e $'s/\t/\\\\t/g' < "$sed_escape_pipe" >&2 &
    exec 2> "$sed_escape_pipe"
    # works, since we won't need to open any new handles to the pipe
    rm -f -- "$sed_escape_pipe"
}

# compare output of snapper list-configs with snapraid.conf
find_configs() {
    # Find snapraid config file
    if ! [[ -r "$config_file" ]] ; then
        printf '%s: Could not read snapraid config file at %s\n' "$0" \
               "$config_file" >&2
        printf 'Please specify a valid snapraid config file with -c\n' >&2
        exit $EXIT_INVALID_ARGUMENT
    elif [[ $verbose -ge 1 ]] ; then
        printf 'Using snapraid config file %s\n' "$config_file"
    fi
    # Find snapper configs with paths in snapraid config file
    local config subvol
    local data_line=$'[ \t]*(data|disk)[ \t]+[^ \t]+[ \t]+'
    while IFS='|' read -r config subvol ; do
        # Remove leading and trailing spaces
        config="${config##*( )}"
        config="${config%%*( )}"
        subvol="${subvol##*( )}"
        subvol="${subvol%%*( )}"
        if grep -Ex "${data_line}${subvol}"$'[/]?[\r]?' \
                "$config_file" > /dev/null
        then
            snapper_configs+=( "$config" )
            snapper_subvols[$config]="$subvol"
        fi
    done < <("$my_snapper" list-configs | tail -n +3)
    if [[ $verbose -ge 0 ]] ; then
        printf 'Snapper configs found matching snapraid config file:\n'
        for i in "${snapper_configs[@]}" ; do
            printf '%s %s\n' "$i" "${snapper_subvols[$i]}"
        done
    fi
}

# replace keywords in use_snapshot with actual snapshot numbers, or with the
# empty string if a snapshot matching the keyword cannot be found
find_snapshots() {
    local snapper_create_opts=( -u "$snapper_userdata" )
    [[ "${snapper_cleanup:-}" ]] &&
        snapper_create_opts+=( -c "$snapper_cleanup" )
    if [[ "${snapper_description:-}" ]] ; then
        snapper_create_opts+=( -d "$snapper_description" )
    else
        snapper_create_opts+=( -d "snapraid-btrfs $1" )
    fi
    local i
    for i in "${snapper_configs[@]}" ; do
        case ${use_snapshot[$i]} in
            diff)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls snapraid-btrfs diff |
                    tail -n 1)" ;;
            last)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls snapraid-btrfs |
                    tail -n 1)" ;;
            new)
                use_snapshot[$i]="$("$my_snapper" -c "$i" create -p \
                    "${snapper_create_opts[@]}")" ;;
            res)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls snapraid-btrfs syncing |
                    tail -n 1)" ;;
            sync)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls snapraid-btrfs synced |
                    tail -n 1)" ;;
            *)
                "$my_snapper" -c "$i" ls | parse_snapper_ls |
                    grep -F "${use_snapshot[$i]}" > /dev/null ||
                    use_snapshot[$i]= ;;
        esac
    done
}

# generate sed script to replace subvolume paths with corresponding snapshots
# (and pool directory, if --pool-dir is specified) and run it on snapraid.conf
generate_temp_snapraid_conf() {
    # regex matching data line up to the point where the path starts
    local data_line=$'^[ \t]\{0,\}data[ \t]\{1,\}[^ \t]\{1,\}[ \t]\{1,\}'
    # no-op to ensure at least one expression is passed to sed
    local sed_exps=( 's/^//' )
    local new_path sed_find sed_replace match_line i
    # shellcheck disable=SC2016
    [[ "${pool_dir:-}" ]] &&
        sed_exps+=( $'/^[ \t]\{0,\}pool[ \t]\{1,\}/d'
                    '$apool '"$pool_dir" )
    for i in "${snapper_configs[@]}" ; do
        if [[ "${use_snapshot[$i]}" -ne 0 ]] ; then
            new_path="${snapper_subvols[$i]}/.snapshots/"
            new_path+="${use_snapshot[$i]}/snapshot"
            if [[ -r "$new_path" ]] ; then
                # use bash builtins to escape slashes in paths for sed
                sed_find="${snapper_subvols[$i]//\//\\\/}"
                sed_replace="${new_path//\//\\\/}"
                match_line="$data_line""$sed_find"$'[\/]\{0,1\}[\r]\{0,1\}$'
                sed_exps+=( "/$match_line/s/$sed_find/$sed_replace/" )
                # also match the deprecated token 'disk' using separate sed
                # expression to avoid depending on the GNU extension \|
                match_line="${match_line/data/disk}"
                sed_exps+=( "/$match_line/s/$sed_find/$sed_replace/" )
            else
                printf '%s: Could not read directory %s\n' "$0" "$new_path" >&2
                exit $EXIT_NO_PERMISSIONS
            fi
        fi
    done
    sed -f <(printf '%s\n' "${sed_exps[@]}") "$config_file"
}

interactive_ask() {
    local choice
    printf 'About to run the command:\n'
    printf '%s ' "$@"
    printf '\n'
    while true ; do
        read -r -p 'Do it [Y/N]? ' choice
        case $choice in
            y|Y)
                break ;;
            n|N)
                exit $EXIT_INTERACTIVE_NO ;;
            *)
                printf 'Invalid choice! Please enter y or n.\n' ;;
        esac
    done
}

invalid_argument() {
    printf '%s: Invalid argument %s!\n' "$0" "$1" >&2
    printf 'Use %s -h to see options.\n' "$0" >&2
    exit $EXIT_INVALID_ARGUMENT
}

main() {
    # bash version 4+ required for associative arrays and
    # ;& and ;;& terminators in case statements
    # 4.1+ required for ACL support
    if ! { [[ "${BASH_VERSINFO[0]}" -gt 4 ]] ||
            { [[ "${BASH_VERSINFO[0]}" -eq 4 ]] &&
                  [[ "${BASH_VERSINFO[1]}" -ge 1 ]] ; } ; }
    then
        printf '%s: bash version 4.1 or greater is required' "$0" >&2
        printf ' to use this script\n' >&2
        exit $EXIT_INTERNAL_ERROR
    fi
    trap 'err_trap ${LINENO} $?' ERR
    # Set default values for "global" configuration variables
    local config_file=/etc/snapraid.conf
    local my_{snapper=snapper,snapraid=snapraid}
    local no_pre_post_option=()
    local pre_post_option=()
    local snapper_configs=()
    local snapper_userdata='snapraid-btrfs=created'
    local verbose=0
    # Declare "global" variables without initial values
    local awk_script interactive pool_dir
    local snapper_{cleanup,description} use_snapshot{,_all}_option
    local -a pre_post_configs
    local -A snapper_subvols use_snapshot pre_snapshots
    read_awk_script
    parse_arguments "$@"
}

# set snapraid-btrfs userdata key to $1
modify_userdata() {
    local ret=0 snapper_ret i
    for i in "${snapper_configs[@]}" ; do
        "$my_snapper" -c "$i" modify -u "snapraid-btrfs=$1" \
                      "${use_snapshot[$i]}" && true
        snapper_ret=$?
        [[ $snapper_ret -eq 0 ]] || ret=$snapper_ret
    done
    return $ret
}

# argument should be a directory, otherwise exit
must_be_directory() {
    if ! [[ -d "$1" ]] ; then
        printf '%s: %s is not a valid directory\n' "$0" "$1" >&2
        exit $EXIT_INVALID_ARGUMENT
    fi
}

# argument should be an executable file, otherwise exit
must_be_executable() {
    if ! [[ -x "$1" ]] ; then
        printf '%s: %s is not an executable file\n' "$0" "$1" >&2
        exit $EXIT_INVALID_ARGUMENT
    fi
}

# call this to make sure $2 is defined when user specifies option requring it
option_requires_argument() {
    if [[ -z "${2:-}" ]] ; then
        printf '%s: Option %s requires an argument!\n' "$0" "$1" >&2
        printf 'Use %s -h for help.\n' "$0" >&2
        exit $EXIT_INVALID_ARGUMENT
    fi
}

parse_arguments() {
    local opt_str length i
    while [[ $# -ge 1 ]] ; do
        case $1 in
            # matching any command means option processing is complete
            check|diff|dup|list|pool|scrub|status|fix|touch|config|create) ;&
            cleanup?(-all)|snapper-l@(s|ist)|?(diff-|d)sync|revert|rollback)
                setup_config
                run_command "$@" ;;
            # snapraid-btrfs options specified before command
            # long form options that don't take arguments
            --@(help|interactive|quiet|verbose|debug)?(=*))
                # ignore any argument passed with --opt=arg format
                set_option "${1%%=*}"
                shift ;;
            # long form options that require arguments
            --@(conf|cleanup|description|pool-dir|use-snapshot?(-all))?(=*)) ;&
            --@(?(no-)pre-post|@(snap@(per-@(path|userdata)|raid-path)))?(=*))
                # allow POSIX --argument option or --argument=option formats
                opt_str="${1%%=*}"
                if [[ "$opt_str" = "$1" ]] ; then
                    set_option "$opt_str" "${2:-}"
                    shift 2 || shift
                else
                    set_option "$opt_str" "${1#${opt_str}=}"
                    shift
                fi ;;
            --*)
                invalid_argument "$1" ;;
            # allow POSIX-style combining of short options
            -*)
                opt_str="${1#-}"
                length="${#opt_str}"
                for ((i=0;i<length;i++)) ; do
                    case ${opt_str:$i:1} in
                        # short options that don't take arguments
                        [hiqvx])
                            set_option "-${opt_str:$i:1}"
                            [[ $((length-1-i)) -eq 0 ]] &&
                                shift ;;
                        # short options that require arguments
                        [cCduU])
                            if [[ $((length-1-i)) -eq 0 ]] ; then
                                set_option "-${opt_str:$i:1}" "${2:-}"
                                shift 2 || shift
                            else
                                set_option "-${opt_str:$i:1}" \
                                           "${opt_str:$((i+1))}"
                                shift
                                break
                            fi ;;
                        *)
                            invalid_argument "-${opt_str:$i:1}" ;;
                    esac
                done ;;
            *)
                invalid_argument "$1" ;;
        esac
    done
    printf '%s: You must specify a command (or you did not ' "$0" >&2
    printf 'specify an argument to an option that requires one)\n' >&2
    printf 'Use %s -h to see options.\n' "$0" >&2
    exit $EXIT_INVALID_ARGUMENT
}

# use awk to parse piped snapper ls output and find snapshot numbers
# matching the specified userdata constraints:
# if $1 and $2 are nonempty, match snapshots with userdata key $1=$2
# else if $1 is nonempty, match snapshots with userdata key $1 defined
# else match all snapshots
parse_snapper_ls() {
    awk -v key="${1:-}" -v value="${2:-}" "$awk_script"
}

# Read awk script from heredoc into variable once here to reduce overhead
# when awk is called in a loop
read_awk_script() {
    read -r -d '' awk_script <<'_EOF_' || true
BEGIN { FS="|" } # snapper separates columns with '|' characters
NR<=2 { next } # first 2 lines are the header
{
    # remove spaces used to pad column width
    gsub(/[ ]+/,"",$2)
    if (key == "") {
        # match all snapshots
        print $2
    } else {
        # split userdata column into key=value pairs in case
        # multiple userdata keys are defined for a snapshot
        split($8,u,",")
        # construct a new array v where the keys are the values from u
        for (i in u) {
            gsub(/^[ ]+/,"",u[i])
            gsub(/[ ]+$/,"",u[i])
            if (value == "") {
                # We don't care about the value of the userdata key, so
                # split key=value pairs and store only the key as a key in v
                split(u[i],w,"=")
                v[w[1]]
            } else {
                # We care about both halves of the userdata key=value
                # pair, so store the whole key=value string as a key in v
                v[u[i]]
            }
        }
        # find and print our matches
        if (value == "") {
            if (key in v) {
                print $2
            }
        } else {
            if (key "=" value in v) {
                print $2
            }
        }
        # Wipe v so one match doesn't result in matching all subsequent lines
        split("",v," ") # delete v only works in gawk
    }
}
_EOF_
}

# Implementation of all commands is in this function
run_command() {
    case $1 in
        # commands that don't invoke snapraid
        cleanup)
            use_snapshot_all sync
            find_snapshots "$1" ;;&
        cleanup-all)
            use_snapshot_all 0 ;;&
        cleanup?(-all))
            cleanup_snapshots
            exit ;;
        config)
            use_snapshot_default last
            find_snapshots "$1"
            use_snapshot_check
            generate_temp_snapraid_conf
            exit ;;
        create)
            use_snapshot_default new
            find_snapshots "$1"
            use_snapshot_check
            exit ;;
        snapper-l@(s|ist))
            shift
            snapper_ls_all "$@"
            exit ;;
        revert|rollback)
            use_snapshot_default sync
            find_snapshots "$1"
            use_snapshot_check ;;&
        revert)
            shift
            snapper_revert "$@"
            exit ;;
        rollback)
            snapper_rollback
            exit ;;
        # commands that invoke snapraid
        @(d|diff-)sync)
            shift
            local diff_ret
            use_snapshot_default new
            find_snapshots "$1"
            use_snapshot_check
            run_snapraid diff "$@" && true
            diff_ret=$?
            # snapraid diff returns 2 if a sync is required
            if [[ $diff_ret -eq 2 ]] ; then
                interactive=1
                run_snapraid sync "$@" && true
                exit
            elif [[ $diff_ret -eq 0 ]] && [[ $verbose -gt 0 ]] ; then
                printf 'No difference, exiting\n'
            fi
            exit $diff_ret ;;
        check|dup|list|pool|scrub|status)
            use_snapshot_default sync
            find_snapshots "$1"
            use_snapshot_check ;;&
        diff|sync)
            use_snapshot_default new
            find_snapshots "$1"
            use_snapshot_check ;;&
        fix|touch)
            use_snapshot_all 0 ;;&
        *)
            run_snapraid "$@" && true
            exit ;;
    esac
}

# Returns exit status of snapraid, postfix calls with '&& true' to avoid
# triggering errexit if snapraid's return status is nonzero
run_snapraid() {
    check_snapraid_arguments "$@"
    local ret
    # Just for display purposes with -v and -i options, not actually used
    local cmd=( "$my_snapraid" "-c" "<(generate_temp_snapraid_conf)" "$@" )
    if [[ $verbose -ge 0 ]] ; then
        printf 'Using snapraid config file:\n'
        generate_temp_snapraid_conf
    fi
    if [[ "${interactive:-}" ]] ; then
        interactive_ask "${cmd[@]}" >&2
    elif [[ $verbose -ge 0 ]] ; then
        printf '%s ' "${cmd[@]}"
        printf '\n'
    fi
    # Create pre/post snapshots if applicable
    case $1 in
        fix|touch)
            create_pre_post_snapshots "$1"
            # shellcheck disable=SC2064
            trap "create_pre_post_snapshots $1 && trap - RETURN" RETURN ;;
    esac
    # If starting sync, update snapper userdata key
    [[ "$1" = sync ]] && modify_userdata syncing
    # Run snapraid
    "$my_snapraid" -c <(generate_temp_snapraid_conf) "$@" && true
    ret=$?
    # Update snapper userdata key to reflect completion
    case $1 in
        diff)
            # snapraid diff returns 0 if no changes, 2 if sync needed
            { [[ $ret -eq 0 ]] || [[ $ret -eq 2 ]] ; } &&
                modify_userdata "$1" ;;
        sync)
            [[ $ret -eq 0 ]] && modify_userdata synced ;;
    esac
    return $ret
}

# $1 is option being set, $2 is argument. If no argument,
# $2 can be either undefined or empty
set_option() {
    case $1 in
        --@(conf|cleanup|description|pool-dir|use-snapshot?(-all))) ;&
        --@(?(no-)pre-post|@(snap@(per-@(path|userdata)|raid-path)))) ;&
        -[cCduU])
            option_requires_argument "$@" ;;&
        -c|--conf)
            config_file="$2" ;;
        -C|--cleanup)
            snapper_cleanup="$2" ;;
        -d|--description)
            snapper_description="$2" ;;
        -h|--help)
            usage
            exit ;;
        -i|--interactive)
            interactive=1 ;;
        -q|--quiet)
            ((--verbose)) ;;
        -u|--use-snapshot-all)
            use_snapshot_all_option="$2" ;;
        -U|--use-snapshot)
            use_snapshot_option="$2" ;;
        -v|--verbose)
            ((++verbose)) ;;
        -x|--debug)
            escape_stderr
            PS4='+(${BASH_SOURCE}:${LINENO}): ${FUNCNAME:+$FUNCNAME(): }'
            set -x ;;
        --no-pre-post)
            IFS=',' read -r -a no_pre_post_option <<< "$2" ;;
        --pool-dir)
            must_be_directory "$2"
            pool_dir="$2" ;;
        --pre-post)
            IFS=',' read -r -a pre_post_option <<< "$2" ;;
        --snapper-path)
            must_be_executable "$2"
            my_snapper="$2" ;;
        --snapper-userdata)
            use_snapper_userdata "$2" ;;
        --snapraid-path)
            must_be_executable "$2"
            my_snapraid="$2" ;;
        *)
            invalid_argument "$1" ;;
    esac
}

# Call immediately after all command line options have been parsed to
# initialize ${snapper_configs[@]} and related arrays
setup_config() {
    check_dependencies
    find_configs
    # Do some sanity checks of snapraid/snapper configuration
    check_config
    # Apply -U option
    [[ "${use_snapshot_option:-}" ]] &&
        apply_use_snapshot_option "$use_snapshot_option"
    local i
    # Set -u argument for any configurations not specified by -U
    if [[ "${use_snapshot_all_option:-}" ]] ; then
        for i in "${snapper_configs[@]}" ; do
            [[ "${use_snapshot[$i]:-}" ]] ||
                use_snapshot[$i]="$use_snapshot_all_option"
        done
    fi
    apply_pre_post_options
}

# Do a snapper ls in all configs, and if argument is specified, additionally
# identify which snapshots we found with userdata snapraid-btrfs=$*
snapper_ls_all() {
    local i
    for i in "${snapper_configs[@]}" ; do
        printf '\n%s %s\n' "$i" "${snapper_subvols[$i]}"
        "$my_snapper" -c "$i" ls
        if [[ $# -ge 1 ]] ; then
            printf 'Snapshots with userdata key snapraid-btrfs=%s:\n' "$*"
            "$my_snapper" -c "$i" ls |
                parse_snapper_ls snapraid-btrfs "$*" | tr '\n' ' '
            printf '\n'
        fi
    done
    printf '\n'
}

# Run snapper undochange in each snapper config to revert to the state at the
# time ${use_snapshot[$i]} was created, creating before and after snapshots
snapper_revert() {
    local ret=0 snapper_ret i
    local -a snapper_cmd
    create_pre_post_snapshots revert
    trap 'create_pre_post_snapshots revert && trap - RETURN' RETURN
    local -a undochange_{opts,files}
    # ensure that -i option, if specified, appears before snapshots
    # and any other arguments specified (except --) appear after snapshots
    while [[ $# -ge 1 ]] ; do
        case $1 in
            --)
                shift
                break ;;
            -i|--input)
                if [[ $# -ge 2 ]] ; then
                    undochange_opts+=( "$1" "$2" )
                    shift 2
                else
                    undochange_files+=( "$1" )
                    shift
                fi ;;
            *)
                undochange_files+=( "$1" )
                shift ;;
        esac
    done
    undochange_files+=( "$@" )
    for i in "${snapper_configs[@]}" ; do
        snapper_cmd=( "$my_snapper" -c "$i" undochange "${undochange_opts[@]}"
                      "${use_snapshot[$i]}..0" "${undochange_files[@]}" )
        if [[ ${interactive:-} ]] ; then
            interactive_ask "${snapper_cmd[@]}" >&2
        elif [[ $verbose -gt 0 ]] ; then
            printf '%s ' "${snapper_cmd[@]}"
            printf '\n'
        fi
        "${snapper_cmd[@]}" && true
        snapper_ret=$?
        [[ $snapper_ret -eq 0 ]] || ret=$snapper_ret
    done
    return $ret
}

# Run snapper rollback in each snapper config
snapper_rollback() {
    local ret=0 snapper_ret i
    local -a snapper_cmd
    local snapper_rollback_opts=( -u "$snapper_userdata" )
    [[ "${snapper_cleanup:-}" ]] ||
        snapper_rollback_opts+=( -c "$snapper_cleanup" )
    if [[ "${snapper_description:-}" ]] ; then
        snapper_rollback_opts+=( -d "$snapper_description" )
    else
        snapper_rollback_opts+=( -d "snapraid-btrfs rollback" )
    fi
    for i in "${snapper_configs[@]}" ; do
        snapper_cmd=( "$my_snapper" -c "$i" rollback
                      "${snapper_rollback_opts[@]}" "${use_snapshot[$i]}" )
        if [[ "${interactive:-}" ]] ; then
            interactive_ask "${snapper_cmd[@]}" >&2
        elif [[ $verbose -gt 0 ]] ; then
            printf '%s ' "${snapper_cmd[@]}"
            printf '\n'
        fi
        "${snapper_cmd[@]}" && true
        snapper_ret=$?
        [[ $snapper_ret -eq 0 ]] || ret=$snapper_ret
    done
    return $ret
}

usage() {
    printf 'Usage: %s [options] <command> [arguments]\n' "$0"
    local doc
    read -r -d '' doc <<'_EOF_' || true

Arguments appearing after the command are passed through to snapraid, while
the following options appearing before the command are interpreted by
snapraid-btrfs:

-h, --help                      Show this help
-c, --conf FILE                 Specify location of snapraid config file
                                (default /etc/snapraid.conf)
-C, --cleanup STR               Specify snapper cleanup algorithm to set for any
                                snapshots created (default none)
-d, --description STR           Specify snapper description to set for any
                                snapshots created
-i, --interactive               Ask before running snapraid or any potentially
                                destructive snapper commands (when using the
                                cleanup(-all), revert, or rollback commands)
-q, --quiet                     Only show snapraid/snapper output and errors
-u, --use-snapshot-all STR      Use one of the following arguments:
                                    diff - Use last snapshot a diff was
                                           completed with
                                    last - Use last snapshots created
                                    new  - Create new snapshots
                                    res  - Resume using snapshots from an
                                           interrupted sync
                                    sync - Use last snapshots a successful sync
                                           was completed with
                                or specify the snapshot number (0 for the live
                                filesystem, following snapper syntax)
                                Default is:
                                    'new' for diff|dsync|sync
                                    'last' for config
                                    'sync' for all other commands
-U, --use-snapshot STR          Specify snapshots to use for specific snapper
                                configurations, using the snapper config name
                                followed by an equals sign. Multiple
                                configurations should be separated by commas,
                                e.g. 'config1=5,config2=last'. Overrides -u
-v, --verbose                   Increase verbosity of output
-x, --debug                     Enable debugging output
--no-pre-post STR               Don't create pre/post snapshots for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
--pool-dir DIR                  Create pool symlinks in DIR (defaults to
                                directory specified in snapraid config file)
--pre-post STR                  Create pre/post snapshots only for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
--snapper-path PATH             Path to the snapper executable (defaults to
                                first found in $PATH)
--snapper-userdata STR          Specify snapper userdata to set for any
                                snapshots created in addition to the
                                "snapraid-btrfs" attribute, which is set by
                                default and cannot be changed. Argument should
                                be in key=value format accepted by snapper,
                                with multiple keys separated by commas (e.g.
                                key1=value1,key2=value2)
--snapraid-path PATH            Path to the snapraid executable (defaults to
                                first found in $PATH)

Commands are either one of the following snapraid commands:
'check'|'diff'|'dup'|'list'|'pool'|'scrub'|'status'|'sync':
        Run the snapraid command given, replacing data drives in snapraid config
        file that have corresponding snapper configs with read-only snapshots.
'fix'|'touch':
        Run the snapraid command given, creating a set of pre/post snapshots
        before and after.

or one of the following snapraid-btrfs specific commands:
'config':
        Show the modified snapraid config file that would be used, but don't
        actually run snapraid.
'create':
        Create a new snapshot for all snapper configs corresponding to data
        drives found in snapraid config file.
'cleanup':
        Delete all snapshots created by snapraid-btrfs before the last one a
        successful sync has been completed with.
'cleanup-all':
        Delete all snapshots created by snapraid-btrfs.
'dsync'|'diff-sync':
        Create a new snapshot for all snapper configs found in snapraid config
        file, do a snapraid diff, then sync. Implies --interactive option for
        the sync operation.
'revert':
        Use snapper undochange to revert the array to the state it was in at
        the time of the last successful sync (or another snapshot if the -u or
        -U option is specified), creating pre/post snapshots. Arguments are
        passed through to snapper undochange, including the snapper undochange
        -i option.
'rollback':
        Run snapper rollback in all snapper configs using the snapshots from
        the last successful sync (or another snapshot if the -u or -U option
        is specified). WARNING: Do not use this command unless you are familiar
        with the snapper rollback command and its effects. Instead consider
        using the revert command.
'snapper-list'|'snapper-ls':
        Run snapper ls for all snapper configs found in snapraid config file.
        If an argument is given, also list which snapshots in each config were
        identified as having snapper userdata key snapraid-btrfs equal to the
        argument (useful for testing purposes).

NOTE: The snapraid '-c' option will not work unless placed before the command,
allowing it to be interpreted as a snapraid-btrfs option. Snapraid will be run
with a temporary configuration file, generated using whatever snapraid.conf file
is specified using the snapraid-btrfs -c option (/etc/snapraid.conf by default)
_EOF_
    printf '%s\n\n' "$doc"
}

# Add key/value pairs from $1 to snapper_userdata, unless key is snapraid-btrfs
use_snapper_userdata() {
    local key value i
    local -a args
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        key=
        value=
        IFS='=' read -r key value <<< "$i"
        [[ "$key" = snapraid-btrfs ]] ||
            snapper_userdata+=",${key}=${value}"
    done
}

# Set use_snapshot to $1 for all configs, overriding any previous values
use_snapshot_all() {
    local i
    for i in "${snapper_configs[@]}" ; do
        use_snapshot[$i]="$1"
    done
}

# If use_snapshot[$i] is the empty string for any snapper config, indicating
# that find_snapshots did not find one, display an error message and exit
use_snapshot_check() {
    local i
    for i in "${snapper_configs[@]}" ; do
        if [[ -z "${use_snapshot[$i]}" ]] ; then
            printf '%s: Could not find a snapshot for config %s\n' "$0" "$i" >&2
            exit $EXIT_SNAPSHOT_NOT_FOUND
        fi
    done
}

# For any configs where use_snapshot is undefined, set it to $1
use_snapshot_default() {
    local i
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]:-}" ]] ||
            use_snapshot[$i]="$1"
    done
}

main "$@"
