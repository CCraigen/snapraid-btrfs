#!/bin/bash -

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# shellcheck disable=SC2221,SC2222
# These warnings don't take ;;& terminators in case statements into account
# see https://github.com/koalaman/shellcheck/issues/1044

readonly DEFAULT_TMPDIR=/tmp
readonly DEFAULT_USERDATA_KEY=snapraid-btrfs
readonly EXIT_INTERNAL_ERROR=64
readonly EXIT_INVALID_ARGUMENT=65
readonly EXIT_INVALID_CONFIG=66
readonly EXIT_NO_PERMISSIONS=67
readonly EXIT_SNAPSHOT_NOT_FOUND=68
readonly EXIT_INTERACTIVE_NO=69
# snapraid short options, sorted by whether or not they accept arguments
readonly SNAPRAID_OPTS_ARG=BCLScdfilop
readonly SNAPRAID_OPTS_NOARG=DEFHLNRUVZaehmqv

# bash version 4+ required for associative arrays, coprocesses, and
# ;& and ;;& terminators in case statements
# 4.1+ required for ACL support and BASH_XTRACEFD
if ! { { ((BASH_VERSINFO[0] == 4)) && ((BASH_VERSINFO[1] >= 1)) ; } ||
           ((BASH_VERSINFO[0] > 4)) ; }
then
    echo 'bash version 4.1+ is required to use this script' >&2
    exit 63
fi

set -Eeuo pipefail +Cfo posix
shopt -s extglob
shopt -u nocasematch
# Use lastpipe if available (bash 4.2+) since it's faster,
# but we don't need the behavior
shopt -s lastpipe &> /dev/null && true

# Apply the --pre-post and --no-pre-post command line options
apply_pre_post_options() {
    local i j
    if ((${#pre_post_option[@]} > 0)) ; then
        for i in "${pre_post_option[@]}" ; do
            config_must_exist "$i"
        done
        pre_post_configs=( "${pre_post_option[@]}" )
    else
        pre_post_configs=( "${snapper_configs[@]}" )
    fi
    if ((${#no_pre_post_option[@]} > 0)) ; then
        local -a temp_array
        for i in "${no_pre_post_option[@]}" ; do
            config_must_exist "$i"
            temp_array=()
            j=
            for j in "${pre_post_configs[@]}" ; do
                [[ "$j" = "$i" ]] || temp_array+=( "$j" )
            done
            pre_post_configs=( "${temp_array[@]}" )
        done
    fi
}

# Set use_snapshot from comma-separated key=value pairs specified in $1
apply_use_snapshot_option() {
    local -a args
    local config config_using i
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        config=
        config_using=
        IFS='=' read -r config config_using <<< "$i"
        config_must_exist "$config"
        use_snapshot[$config]="$config_using"
    done
}

# substitute for cat that doesn't invoke any external processes
cat_builtin() {
    local buf
    local -i fd
    if [[ "${1:-}" ]] ; then
        exec {fd}<"$1"
    else
        exec {fd}<&0
    fi
    IFS= read -r -d '' -u "$fd" buf && true
    eval "exec ${fd}<&-"
    printf '%s' "$buf"
}

check_config() {
    # Make sure we found some configs
    if ((${#snapper_configs[@]} == 0)) ; then
        printf '%s: No snapper configs found for any data drives in %s\n' \
               "$my_name" "$config_file" >&2
        exit $EXIT_INVALID_CONFIG
    fi
    # We don't want to snapshot the content files. So, check the directories of
    # the content files, and compare their mount points with those of the
    # subvolumes we are snapshotting, to see if any match
    local field1 field2 content_dir content_mount i
    # No need for an if [[ -r "$config_file" ]] here,
    # since this is our second pass
    while IFS=$' \t' read -r field1 field2 ; do
        if [[ "$field1" = content ]] ; then
            content_dir="$(dirname -- "$field2")"
            content_mount="$(stat --format=%m -- "$content_dir")"
            for i in "${snapper_configs[@]}" ; do
                if [[ "$content_mount" -ef "${snapper_subvols[$i]}" ]] ; then
                    printf '%s: %s found in data subvolume %s - %s\n' \
                           "$my_name" "$field2" "${snapper_subvols[$i]}" \
                           'content files must be in separate subvolume' >&2
                    exit $EXIT_INVALID_CONFIG
                fi
            done
        fi
    done < "$config_file"
    # Check to make sure the user has permission to access snapshots
    for i in "${snapper_configs[@]}" ; do
        # Try a snapper ls first, in case ACLs need to be refreshed
        if ! { "$my_snapper" -c "$i" ls &> /dev/null &&
                   [[ -r "${snapper_subvols[$i]}/.snapshots" ]] &&
                   is_btrfs_subvolume "${snapper_subvols[$i]}/.snapshots" ; }
        then
            printf '%s: Could not read subvolume %s - is SYNC_ACL set?\n' \
                   "$my_name" "${snapper_subvols[$i]}/.snapshots" >&2
            exit $EXIT_NO_PERMISSIONS
        fi
    done
}

# Make sure all external binaries in $@ can be found in $PATH
check_dependencies() {
    local i
    for i in "$@" ; do
        if ! type "$i" &> /dev/null ; then
            # shellcheck disable=SC2016
            # we really do want to print the literal string $PATH
            printf '%s: Could not find %s in $PATH\n' "$my_name" "$i" >&2
            exit $EXIT_INTERNAL_ERROR
        fi
    done
}

# Make sure the user hasn't tried to pass through the -c option to snapraid
check_snapraid_arguments() {
    while (($# > 0)) ; do
        case $1 in
            --conf|-*(["$SNAPRAID_OPTS_NOARG"])c*)
                printf '%s: The -c/--conf option may not be passed through\n' \
                       "$my_name" >&2
                invalid_argument_exit ;;
            # snapraid options that take arguments, meaning we should shift 2
            --@(filter?(-disk)|import|plan|older-than|log|start|count)) ;&
            --@(error-limit|gen-conf)) ;&
            -["$SNAPRAID_OPTS_ARG"])
                shift 2 || shift ;;
            *)
                shift ;;
        esac
    done
}

# In each config, delete snapshots with userdata key $snapper_userdata_key
# created before use_snapshot[$i], or all such snapshots if use_snapshot[$i]=0
cleanup_snapshots() {
    local i j
    local -i ret snapper_ret
    local -a snapper_cmd snapshots_to_consider
    ret=0
    for i in "${snapper_configs[@]}" ; do
        # skip this config if we couldn't find a synced snapshot
        if [[ -z "${use_snapshot[$i]}" ]] ; then
            if ((verbose >= 0)) ; then
                printf 'No synced snapshot found for config %s, skipping\n' \
                       "$i" >&2
            fi
            continue
        fi
        snapshots_to_consider=()
        IFS=' ' read -r -a snapshots_to_consider \
           < <("$my_snapper" -c "$i" ls |
                   parse_snapper_ls "$snapper_userdata_key" '' ' ') && true
        j=
        for j in "${snapshots_to_consider[@]}" ; do
            if [[ "${use_snapshot[$i]}" != "$j" ]] ; then
                snapper_cmd=( "$my_snapper" -c "$i" rm "$j" )
                verbose_command "${snapper_cmd[@]}"
                "${snapper_cmd[@]}" && true
                snapper_ret=$?
                if ((snapper_ret != 0)) ; then
                    ret=$snapper_ret
                fi
            fi
        done
    done
    return $ret
}

# Check that the user didn't specify a nonexistent snapper config by ensuring
# that a subvolume is set for the config name
config_must_exist() {
    if ! [[ "${snapper_subvols[$1]:-}" ]] ; then
        printf '%s: Invalid snapper configuration %s!\n' "$my_name" "$1" >&2
        invalid_argument_exit
    fi
}

# Calling once creates pre snapshots, calling again creates corresponding post
create_pre_post_snapshots() {
    local -a snapper_cmd
    local i
    for i in "${pre_post_configs[@]}" ; do
        # skip configs where we're using a readonly snapshot
        [[ "${use_snapshot[$i]}" = 0 ]] || continue
        snapper_cmd=( "$my_snapper" -c "$i" create )
        [[ "$snapper_cleanup" ]] &&
            snapper_cmd+=( -c "$snapper_cleanup" )
        snapper_cmd+=( -u "$snapper_userdata" )
        # Check if we've already done a pre snapshot
        if [[ "${pre_snapshot[$i]:-}" ]] ; then
            # We've already done pre snapshots, so create corresponding post
            if [[ "$snapper_description" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "$my_name post-$1" )
            fi
            snapper_cmd+=( -t post --pre-number "${pre_snapshot[$i]}" )
            "${snapper_cmd[@]}" && true
        else
            # We haven't created pre snapshots yet, so create them and store the
            # snapshot numbers from snapper -p option in ${pre_snapshot[@]}
            if [[ "$snapper_description" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "$my_name pre-$1" )
            fi
            snapper_cmd+=( -t pre -p )
            pre_snapshot[$i]="$("${snapper_cmd[@]}")"
        fi
    done
}

# run the specified snapper command on each config
do_snapper() {
    local i
    local -a snapper_cmd
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        snapper_cmd=( "$my_snapper" -c "$i" "$@" )
        verbose_command "${snapper_cmd[@]}"
        "${snapper_cmd[@]}"
    done
}

# Enable xtrace with a useful $PS4 setting and replace literal tab
# characters in xtrace with the escape sequence \t in reversed color
# Literal \t sequences are not replaced by \\t in order to preserve
# readability - ambiguity should be minimal
enable_debug_mode() {
    original_BASH_XTRACEFD="${BASH_XTRACEFD:-2}"
    coproc sed_escape_xtrace {
        sed $'s/\t/\e[7m\\\\t\e[0m/g'
    } >&"$original_BASH_XTRACEFD"
    BASH_XTRACEFD=${sed_escape_xtrace[1]}
    PS4='+(${BASH_SOURCE[0]}:$LINENO): ${FUNCNAME[0]:+${FUNCNAME[0]}(): }'
    set -x
}

# Intended to be called by ERR trap. Accepts the following arguments:
# $1 - Line number where ERR condition occurred
# $2 - Command that caused the ERR condition
# $3 - Exit status that caused the ERR condition
err_trap() {
    printf '%s: %s: %s failed with exit status %s\n%s\n' "$my_name" \
           "${1:-?}" "${2:-unknown command}" "${3:-unknown}" \
           'Stack trace:' >&2
    local func line script
    local -i frame
    frame=0
    while IFS=' ' read -r line func script ; do
        printf '%s: %s: %s\n' "$script" "$func" "$line" >&2
    done < <(while caller $frame ; do ((++frame)) ; done)
    exit "${3:-$EXIT_INTERNAL_ERROR}"
}

# Intended to be called by EXIT trap
# Removes $rm_on_exit if nonempty and cleans up coprocess if necessary
exit_trap() {
    if ((${#rm_on_exit[@]} > 0)) ; then
        rm -f -- "${rm_on_exit[@]}" && true
    fi
    if [[ "${original_BASH_XTRACEFD:-}" ]] ; then
        local -i temp_BASH_XTRACEFD
        temp_BASH_XTRACEFD="$BASH_XTRACEFD"
        BASH_XTRACEFD="$original_BASH_XTRACEFD"
        case $temp_BASH_XTRACEFD in
            !(2|"$BASH_XTRACEFD"))
                eval "exec ${temp_BASH_XTRACEFD}>&-" ;;
        esac
        # shellcheck disable=SC2086,SC2154
        # Shellcheck doesn't understand named coprocesses
        # See https://github.com/koalaman/shellcheck/issues/1066
        wait $sed_escape_xtrace_PID
    fi
    return 0
}

# compare output of snapper list-configs with snapraid.conf
find_configs() {
    # Find snapraid config file
    if ! [[ -r "$config_file" ]] ; then
        printf '%s: Could not read snapraid config file at %s\n' "$my_name" \
               "$config_file" >&2
        invalid_argument_exit
    elif ((verbose > 0)) ; then
        printf 'Using snapraid config file %s\n' "$config_file"
    fi
    # Find snapper configs with paths in snapraid config file
    local config data_line subvol i
    # grep ERE matching data line up to the point where the path starts
    readonly data_line=$'[ \t]*(data|disk)[ \t]+[^ \t]+[ \t]+'
    while IFS='|' read -r config subvol ; do
        # Remove leading and trailing spaces
        config="${config##*( )}"
        config="${config%%*( )}"
        subvol="${subvol##*( )}"
        subvol="${subvol%%*( )}"
        # allow trailing slash
        if grep -Ex "$data_line$subvol"'[/]?' \
                "$config_file" > /dev/null
        then
            snapper_configs+=( "$config" )
            snapper_subvols[$config]="$subvol"
        fi
    done < <("$my_snapper" list-configs | tail -n +3)
    if ((verbose >= 0)) ; then
        printf 'Snapper configs found:\n'
        for i in "${snapper_configs[@]}" ; do
            printf '%s %s\n' "$i" "${snapper_subvols[$i]}"
        done
    fi
}

# replace keywords in use_snapshot with actual snapshot numbers, or with the
# empty string if a snapshot matching the keyword cannot be found
find_snapshots() {
    local -a snapper_create_opts
    snapper_create_opts=( -u "$snapper_userdata" )
    [[ "$snapper_cleanup" ]] &&
        snapper_create_opts+=( -c "$snapper_cleanup" )
    if [[ "$snapper_description" ]] ; then
        snapper_create_opts+=( -d "$snapper_description" )
    else
        snapper_create_opts+=( -d "$my_name $1" )
    fi
    local i
    for i in "${snapper_configs[@]}" ; do
        case ${use_snapshot[$i]} in
            diff)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" diff |
                    tail -n 1)" ;;
            last)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" |
                    tail -n 1)" ;;
            new)
                use_snapshot[$i]="$("$my_snapper" -c "$i" create -p \
                    "${snapper_create_opts[@]}")"
                if ((verbose > 0)) ; then
                    printf 'Created new snapshot %s for config %s\n' \
                           "${use_snapshot[$i]}" "$i"
                fi ;;
            res)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" syncing |
                    tail -n 1)" ;;
            sync)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" synced |
                    tail -n 1)" ;;
            0)
                continue ;;
            +([[:digit:]]))
                "$my_snapper" -c "$i" ls |
                    parse_snapper_ls |
                    grep -Fx "${use_snapshot[$i]}" > /dev/null ||
                    use_snapshot[$i]= ;;
            *)
                printf '%s: Could not understand snapshot selection %s%s%s\n' \
                       "$my_name" "${use_snapshot[$i]}" ' for config ' "$i" >&2
                invalid_argument_exit ;;
        esac
        if ((verbose > 0)) ; then
            printf 'Using snapshot %s for config %s\n' \
                   "${use_snapshot[$i]}" "$i"
        fi
    done
}

# generate sed script to replace subvolume paths with corresponding snapshots
# (and pool directory, if --pool-dir is specified) and run it on snapraid.conf
generate_temp_snapraid_conf() {
    local data_line match_line new_path sed_find sed_replace i
    local -a sed_exps
    # regex matching data line up to the point where the path starts
    readonly data_line=$'^[ \t]*data[ \t]\{1,\}[^ \t]\{1,\}[ \t]\{1,\}'
    sed_exps=()
    if [[ "$pool_dir" ]] ; then
        # shellcheck disable=SC2016
        # $a is a sed command, not part of a bash variable, so is single quoted
        sed_exps+=( $'/^[ \t]*pool[ \t]\{1,\}/d'
                    '$apool '"$pool_dir" )
    fi
    for i in "${snapper_configs[@]}" ; do
        if [[ "${use_snapshot[$i]}" != 0 ]] ; then
            new_path="${snapper_subvols[$i]}/.snapshots/"
            new_path+="${use_snapshot[$i]}/snapshot"
            if [[ -r "$new_path" ]] && is_btrfs_subvolume "$new_path" ; then
                # Escape special characters in paths so that they can be
                # passed to sed as literal strings
                sed_find="$(sed 's/[].*$^/\[]/\\&/g' \
                                <<< "${snapper_subvols[$i]}")"
                sed_replace="$(sed 's/[&/\]/\\&/g' <<< "$new_path")"
                match_line="$data_line$sed_find"'[\/]\{0,1\}$'
                sed_exps+=( "/$match_line/s/$sed_find/$sed_replace/" )
                # also match the deprecated token 'disk' using separate sed
                # expression to avoid depending on the GNU extension \|
                match_line="${match_line/data/disk}"
                sed_exps+=( "/$match_line/s/$sed_find/$sed_replace/" )
            else
                printf '%s: Could not read subvolume %s\n' \
                       "$my_name" "$new_path" >&2
                exit $EXIT_NO_PERMISSIONS
            fi
        fi
    done
    if ((${#sed_exps[@]} == 0)) ; then
        cat_builtin "$config_file"
    else
        sed -f <(printf '%s\n' "${sed_exps[@]}") -- "$config_file"
    fi
}

# given the snapraid.conf name for a disk (e.g. d1 in disk d1 /foo/bar),
# find the corresponding snapper config name, if any
get_snapper_config_name() {
    local field1 field2 field3 subvol i
    subvol=
    while IFS=$' \t' read -r field1 field2 field3 ; do
        case $field1 in
            data|disk)
                if [[ "$field2" = "$1" ]] ; then
                    subvol="$field3"
                    break
                fi ;;
        esac
    done < "$config_file"
    [[ "$subvol" ]] || return
    for i in "${snapper_configs[@]}" ; do
        if [[ "${snapper_subvols[$i]}" = "$subvol" ]] ; then
            printf '%s\n' "$i"
            break
        fi
    done
}

interactive_ask() {
    local choice
    printf 'About to run the command:\n'
    printf '%s ' "$@"
    printf '\n'
    while true ; do
        read -r -p 'Do it [Y/N]? ' choice
        case $choice in
            y|Y)
                break ;;
            n|N)
                exit $EXIT_INTERACTIVE_NO ;;
            *)
                printf 'Invalid choice. Please enter y or n.\n' ;;
        esac
    done
}

invalid_argument() {
    printf '%s: Invalid argument %s\n' "$my_name" "$1" >&2
    invalid_argument_exit
}

invalid_argument_exit() {
    printf 'Use %s -h for help\n' "$my_name" >&2
    exit $EXIT_INVALID_ARGUMENT
}

# Returns:
# 0 if $1 is a btrfs subvolume
# 1 if $1 is an "empty subvolume" inside a snapshot
# 2 if $1 is an ordinary directory
# 3 if $1 is not a directory
# 4 if we couldn't determine the inode number with stat
is_btrfs_subvolume() {
    [[ -d "$1" ]] || return 3
    case $(stat --format=%i -- "$1") in
        256)
            return 0 ;;
        2)
            return 1 ;;
        '')
            return 4 ;;
        *)
            return 2 ;;
    esac
}

main() {
    check_dependencies awk basename dirname grep mktemp rm sed stat tail
    local config_file my_name my_snapper my_snapraid original_BASH_XTRACEFD \
          pool_dir snapper_cleanup snapper_description snapper_userdata \
          snapper_userdata_key use_snapshot_all_option use_snapshot_option
    local -i interactive verbose
    local -a no_pre_post_option pre_post_configs pre_post_option \
          rm_on_exit snapper_configs
    local -A pre_snapshot snapper_subvols use_snapshot
    trap 'err_trap $LINENO "$BASH_COMMAND" $?' ERR
    trap 'exit_trap' EXIT
    # if SNAPRAID_CONFIG_FILE is set, use it as default config file location if
    # the -c/--conf option is unset, otherwise follow snapraid behavior of
    # using /usr/local/etc/snapraid.conf as the default if it exists, and
    # /etc/snapraid.conf otherwise
    if [[ "${SNAPRAID_CONFIG_FILE:-}" ]] ; then
        config_file="$SNAPRAID_CONFIG_FILE"
    elif [[ -f /usr/local/etc/snapraid.conf ]] ; then
        config_file=/usr/local/etc/snapraid.conf
    else
        config_file=/etc/snapraid.conf
    fi
    interactive=0
    my_name="$(basename -- "${BASH_SOURCE[0]}")"
    my_snapper=snapper
    my_snapraid=snapraid
    no_pre_post_option=()
    original_BASH_XTRACEFD=
    pool_dir=
    pre_post_option=()
    rm_on_exit=()
    snapper_cleanup=
    snapper_configs=()
    snapper_description=
    snapper_userdata_key="${SNAPRAID_USERDATA_KEY:-$DEFAULT_USERDATA_KEY}"
    snapper_userdata="$snapper_userdata_key=created"
    use_snapshot_all_option=
    use_snapshot_option=
    verbose=0
    parse_arguments "$@"
}

# set $snapper_userdata_key userdata key to $1
modify_userdata() {
    local i
    local -i ret snapper_ret
    ret=0
    for i in "${snapper_configs[@]}" ; do
        "$my_snapper" -c "$i" modify -u "$snapper_userdata_key=$1" \
                      "${use_snapshot[$i]}" && true
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    return $ret
}

must_be_directory() {
    if ! [[ -d "$1" ]] ; then
        printf '%s: %s is not a valid directory\n' "$my_name" "$1" >&2
        invalid_argument_exit
    fi
}

must_be_executable() {
    if ! [[ -x "$1" ]] ; then
        printf '%s: %s is not an executable file\n' "$my_name" "$1" >&2
        invalid_argument_exit
    fi
}

must_be_writable() {
    if ! [[ -w "$1" ]] ; then
        printf '%s: No write permission for %s - %s\n' "$my_name" "$1" \
               'set the TMPDIR environment variable and try again' >&2
        exit $EXIT_NO_PERMISSIONS
    fi
}

# call this to make sure $2 is defined when user specifies option requring it
option_requires_argument() {
    if [[ -z "${2:-}" ]] ; then
        printf '%s: Option %s requires an argument\n' "$my_name" "$1" >&2
        invalid_argument_exit
    fi
}

parse_arguments() {
    local opt_str
    local -i length i
    while (($# > 0)) ; do
        case $1 in
            # matching any command means option processing is complete
            check|diff|dup|list|pool|scrub|status|fix|touch) ;&
            cleanup?(-all)|l@(s|ist)|?(diff-|d)sync) ;&
            config|create|resume|rollback|snapper|undochange)
                setup_config
                run_command "$@" ;;
            # snapraid-btrfs options specified before command
            # long form options that don't take arguments
            --@(help|interactive|quiet|verbose|debug)?(=*))
                # ignore any argument passed with --opt=arg format
                set_option "${1%%=*}"
                shift ;;
            # long form options that require arguments
            --@(conf|cleanup|description|pool-dir|use-snapshot?(-all))?(=*)) ;&
            --@(?(no-)pre-post|@(snap@(per-@(path|userdata)|raid-path)))?(=*))
                # allow POSIX --argument option or --argument=option formats
                opt_str="${1%%=*}"
                if [[ "$opt_str" = "$1" ]] ; then
                    set_option "$opt_str" "${2:-}"
                    shift 2 || shift
                else
                    set_option "$opt_str" "${1#$opt_str=}"
                    shift
                fi ;;
            --*)
                invalid_argument "$1" ;;
            # allow POSIX-style combining of short options
            -*)
                opt_str="${1#-}"
                length="${#opt_str}"
                for ((i=0;i<length;i++)) ; do
                    case ${opt_str:$i:1} in
                        # short options that don't take arguments
                        [hiqvx])
                            set_option "-${opt_str:$i:1}"
                            if ((i == length-1)) ; then
                                shift
                            fi ;;
                        # short options that require arguments
                        [cCduU])
                            if ((i == length-1)) ; then
                                set_option "-${opt_str:$i:1}" "${2:-}"
                                shift 2 || shift
                            else
                                set_option "-${opt_str:$i:1}" \
                                           "${opt_str:$((i+1))}"
                                shift
                                break
                            fi ;;
                        *)
                            invalid_argument "-${opt_str:$i:1}" ;;
                    esac
                done ;;
            *)
                invalid_argument "$1" ;;
        esac
    done
    printf '%s: No command specified\n' "$my_name" >&2
    invalid_argument_exit
}

# use awk to parse piped snapper ls output and find snapshot numbers
# matching the specified userdata constraints:
# if $1 and $2 are nonempty, match snapshots with userdata key $1=$2
# else if $1 is nonempty, match snapshots with userdata key $1 defined
# else match all snapshots
# if multiple snapshots match, separate their numbers with $3, or
# if $3 is undefined, separate the snapshot numbers with newlines
parse_snapper_ls() {
    awk -F '|' \
        -v key="${1:-}" \
        -v value="${2:-}" \
        -v ORS="${3:-$'\n'}" \
        -f <(cat_builtin <<'_EOF_'
# first 2 lines are the header
NR<=2 { next }
{
    # remove spaces used to pad column width
    gsub(/[ ]+/,"",$2)
    if (key == "") {
        # match all snapshots
        print $2
    } else {
        # split userdata column into key=value pairs in case
        # multiple userdata keys are defined for a snapshot
        split($8,u,",")
        # construct a new array v where the keys are the values from u
        for (i in u) {
            # remove padding spaces
            gsub(/^[ ]+/,"",u[i])
            gsub(/[ ]+$/,"",u[i])
            if (value == "") {
                # We don't care about the value of the userdata key, so
                # split key=value pairs and store only the key as a key in v
                split(u[i],w,"=")
                v[w[1]]
            } else {
                # We care about both halves of the userdata key=value
                # pair, so store the whole key=value string as a key in v
                v[u[i]]
            }
        }
        # find and print our matches
        if (value == "") {
            if (key in v) {
                print $2
            }
        } else {
            if (key "=" value in v) {
                print $2
            }
        }
        # Wipe v so one match doesn't result in matching all subsequent lines
        # delete v only works in gawk
        split("",v," ")
    }
}
_EOF_
            )
}

# Run the command given in $1
run_command() {
    case $1 in
        # Setup ${use_snapshot[@]}
        cleanup)
            use_snapshot_all sync ;;&
        cleanup-all|touch)
            use_snapshot_all 0 ;;&
        config)
            use_snapshot_default last ;;&
        check|dup|pool|rollback|scrub|status|undochange)
            use_snapshot_default sync ;;&
        create|diff|?(d|diff-)sync)
            use_snapshot_default new ;;&
        fix)
            use_snapshot_fix "$@" ;;&
        resume)
            use_snapshot_default res ;;&
        snapper)
            use_snapshot_default '' ;;&
        !(cleanup-all|l@(s|ist)|snapper|touch))
            find_snapshots "$1" ;;&
        !(cleanup?(-all)|l@(s|ist)|snapper|touch))
            use_snapshot_check ;;&
        # Implementation of commands that don't invoke snapraid
        cleanup?(-all))
            cleanup_snapshots ;;
        config)
            generate_temp_snapraid_conf ;;
        l@(s|ist))
            shift
            snapper_ls "$@" ;;
        rollback)
            snapper_rollback ;;
        snapper)
            shift
            do_snapper "$@" ;;
        undochange)
            shift
            snapper_undochange "$@" ;;
        # Implementation of commands that invoke snapraid
        check|diff|dup|fix|pool|scrub|status|sync|touch)
            run_snapraid "$@" && true ;;
        resume)
            shift
            run_snapraid sync "$@" && true ;;
        @(d|diff-)sync)
            shift
            local -i diff_ret
            run_snapraid diff "$@" && true
            diff_ret=$?
            # snapraid diff returns 2 if a sync is required
            if ((diff_ret == 2)) ; then
                ((++interactive))
                run_snapraid sync "$@" && true
            else
                exit $diff_ret
            fi ;;
    esac
    exit
}

# Returns exit status of snapraid, postfix calls with '&& true' to avoid
# triggering errexit if snapraid's return status is nonzero
run_snapraid() {
    check_snapraid_arguments "$@"
    local temp_config_file temp_dir
    local -i ret
    local -a snapraid_cmd
    temp_dir="${TMPDIR:-$DEFAULT_TMPDIR}"
    must_be_writable "$temp_dir"
    temp_config_file="$(mktemp -- "$temp_dir/$my_name.XXXXXX")"
    rm_on_exit+=( "$temp_config_file" )
    must_be_writable "$temp_config_file"
    generate_temp_snapraid_conf > "$temp_config_file"
    snapraid_cmd=( "$my_snapraid" -c "$temp_config_file" "$@" )
    if ((verbose >= 0)) ; then
        printf 'Using snapraid config file:\n'
        cat_builtin "$temp_config_file"
    fi
    verbose_command "${snapraid_cmd[@]}"
    case $1 in
        # Create pre/post snapshots if applicable
        fix|touch)
            create_pre_post_snapshots "$1" ;;
        # If starting sync, update snapper userdata key
        sync)
            modify_userdata syncing ;;
    esac
    # Run snapraid
    "${snapraid_cmd[@]}" && true
    ret=$?
    # Update snapper userdata key to reflect completion
    case $1 in
        fix|touch)
            create_pre_post_snapshots "$1" ;;
        diff)
            # snapraid diff returns 0 if no changes, 2 if sync needed
            if ((ret == 0)) || ((ret == 2)) ; then
                modify_userdata "$1"
            fi ;;
        sync)
            if ((ret == 0)) ; then
                modify_userdata synced
            fi ;;
    esac
    return $ret
}

# $1 is option being set, $2 is argument. If no argument,
# $2 can be either undefined or empty
set_option() {
    case $1 in
        --@(conf|cleanup|description|pool-dir|use-snapshot?(-all))) ;&
        --@(?(no-)pre-post|@(snap@(per-@(path|userdata)|raid-path)))) ;&
        -[cCduU])
            option_requires_argument "$@" ;;&
        -c|--conf)
            config_file="$2" ;;
        -C|--cleanup)
            snapper_cleanup="$2" ;;
        -d|--description)
            snapper_description="$2" ;;
        -h|--help)
            usage
            exit ;;
        -i|--interactive)
            ((++interactive)) ;;
        -q|--quiet)
            ((--verbose)) ;;
        -u|--use-snapshot-all)
            use_snapshot_all_option="$2" ;;
        -U|--use-snapshot)
            use_snapshot_option="$2" ;;
        -v|--verbose)
            ((++verbose)) ;;
        -x|--debug)
            enable_debug_mode ;;
        --no-pre-post)
            IFS=',' read -r -a no_pre_post_option <<< "$2" ;;
        --pool-dir)
            must_be_directory "$2"
            pool_dir="$2" ;;
        --pre-post)
            IFS=',' read -r -a pre_post_option <<< "$2" ;;
        --snapper-path)
            must_be_executable "$2"
            my_snapper="$2" ;;
        --snapper-userdata)
            use_snapper_userdata "$2" ;;
        --snapraid-path)
            must_be_executable "$2"
            my_snapraid="$2" ;;
        *)
            invalid_argument "$1" ;;
    esac
}

# Call immediately after all command line options have been parsed to
# initialize ${snapper_configs[@]} and related arrays
setup_config() {
    # Check for snapraid and snapper now that option processing is complete
    check_dependencies "$my_snapper" "$my_snapraid"
    # Populate arrays
    find_configs
    # Do some sanity checks of the configuration we just read
    check_config
    # Apply -U option
    [[ "$use_snapshot_option" ]] &&
        apply_use_snapshot_option "$use_snapshot_option"
    local i
    # Set -u argument for any configurations not specified by -U
    if [[ "$use_snapshot_all_option" ]] ; then
        for i in "${snapper_configs[@]}" ; do
            [[ "${use_snapshot[$i]:-}" ]] ||
                use_snapshot[$i]="$use_snapshot_all_option"
        done
    fi
    apply_pre_post_options
}

# Do a snapper ls in all configs, and if argument is specified, additionally
# identify which snapshots we found with userdata $snapper_userdata_key=$*
snapper_ls() {
    local i
    for i in "${snapper_configs[@]}" ; do
        printf '\n%s %s\n' "$i" "${snapper_subvols[$i]}"
        "$my_snapper" -c "$i" ls
        if (($# > 0)) ; then
            printf 'Snapshots with userdata key %s=%s:\n' \
                   "$snapper_userdata_key" "$*"
            "$my_snapper" -c "$i" ls |
                parse_snapper_ls "$snapper_userdata_key" "$*" ' '
            printf '\n'
        fi
    done
    printf '\n'
}

# Run snapper rollback in each snapper config
snapper_rollback() {
    local i
    local -i ret snapper_ret
    local -a snapper_cmd snapper_rollback_opts
    ret=0
    snapper_rollback_opts=( -u "$snapper_userdata" )
    [[ "$snapper_cleanup" ]] ||
        snapper_rollback_opts+=( -c "$snapper_cleanup" )
    if [[ "$snapper_description" ]] ; then
        snapper_rollback_opts+=( -d "$snapper_description" )
    else
        snapper_rollback_opts+=( -d "$my_name rollback" )
    fi
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        snapper_cmd=( "$my_snapper" -c "$i" rollback
                      "${snapper_rollback_opts[@]}" "${use_snapshot[$i]}" )
        verbose_command "${snapper_cmd[@]}"
        "${snapper_cmd[@]}" && true
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    return $ret
}

# Run snapper undochange in each snapper config to revert to the state at the
# time ${use_snapshot[$i]} was created, creating before and after snapshots
snapper_undochange() {
    local i
    local -i ret snapper_ret
    local -a snapper_cmd undochange_files undochange_opts
    ret=0
    undochange_files=()
    undochange_opts=()
    create_pre_post_snapshots undochange
    # ensure that -i option, if specified, appears before snapshots
    # and any other arguments specified (except --) appear after snapshots
    while (($# > 0)) ; do
        case $1 in
            --)
                shift
                break ;;
            -i|--input)
                if (($# > 1)) ; then
                    undochange_opts+=( "$1" "$2" )
                    shift 2
                else
                    undochange_files+=( "$1" )
                    shift
                fi ;;
            *)
                undochange_files+=( "$1" )
                shift ;;
        esac
    done
    undochange_files+=( "$@" )
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        snapper_cmd=( "$my_snapper" -c "$i" undochange "${undochange_opts[@]}"
                      "${use_snapshot[$i]}..0" -- "${undochange_files[@]}" )
        verbose_command "${snapper_cmd[@]}"
        "${snapper_cmd[@]}" && true
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    create_pre_post_snapshots undochange
    return $ret
}

usage() {
    cat_builtin <<_EOF_
Usage: $my_name [options] <command> [arguments]

Arguments appearing after the command are passed through to snapraid, while
the following options appearing before the command are interpreted by
$my_name:

  -h, --help                    Show this help
  -c, --conf FILE               Specify location of snapraid config file
                                (default /usr/local/etc/snapraid.conf if it
                                exists, otherwise /etc/snapraid.conf)
  -C, --cleanup STR             Specify snapper cleanup algorithm to set for any
                                snapshots created (default none)
  -d, --description STR         Specify snapper description to set for any
                                snapshots created
  -i, --interactive             Ask before running snapraid or any potentially
                                destructive snapper commands (when using the
                                cleanup(-all), rollback, or undochange commands)
  -q, --quiet                   Only show snapraid/snapper output and errors
  -u, --use-snapshot-all STR    Use one of the following arguments:
                                    diff - Use last snapshot a diff was
                                           completed with
                                    last - Use last snapshots created
                                    new  - Create new snapshots
                                    res  - Resume using snapshots from an
                                           interrupted sync
                                    sync - Use last snapshots a successful sync
                                           was completed with
                                or specify the snapshot number (0 for the live
                                filesystem, following snapper syntax)
                                Default is:
                                    'new' for diff|dsync|sync
                                    'last' for config
                                    'res' for resume
                                    'sync' for all other commands
  -U, --use-snapshot STR        Specify snapshots to use for specific snapper
                                configurations, using the snapper config name
                                followed by an equals sign. Multiple
                                configurations should be separated by commas,
                                e.g. 'config1=5,config2=last'. Overrides -u
  -v, --verbose                 Increase verbosity of output
  -x, --debug                   Enable debugging output
  --no-pre-post STR             Don't create pre/post snapshots for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
  --pool-dir DIR                Create pool symlinks in DIR (defaults to
                                directory specified in snapraid config file)
  --pre-post STR                Create pre/post snapshots only for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
  --snapper-path PATH           Path to the snapper executable (defaults to
                                first found in \$PATH)
  --snapper-userdata STR        Specify snapper userdata to set for any
                                snapshots created in addition to the
                                $my_name attribute, which is set by
                                default and cannot be changed. Argument should
                                be in key=value format accepted by snapper,
                                with multiple keys separated by commas (e.g.
                                key1=value1,key2=value2)
  --snapraid-path PATH          Path to the snapraid executable (defaults to
                                first found in \$PATH)

  NOTE: The snapraid -c/--conf option will not work unless placed before the
  command, allowing it to be interpreted as a $my_name option. Snapraid will be
  run with a temporary configuration file, generated using whatever
  snapraid.conf file is specified using the $my_name -c/--conf option.

Commands are either one of the following snapraid commands:
  'check'|'diff'|'dup'|'pool'|'scrub'|'status'|'sync':
        Run the snapraid command given, replacing data drives in snapraid config
        file that have corresponding snapper configs with read-only snapshots.
  'fix'|'touch':
        Run the snapraid command given, creating a set of pre/post snapshots
        before and after (for fix, if the snapraid -d/--filter-disk option is
        specified, create pre/post snapshots only for the specified disk(s),
        and use the last-synced snapshot for the rest).

or one of the following $my_name specific commands:
  'config':
        Show the modified snapraid config file that would be used, but don't
        actually run snapraid.
  'create':
        Create a new snapshot for all snapper configs corresponding to data
        drives found in snapraid config file.
  'cleanup':
        Delete all snapshots created by $my_name except the last one a
        successful sync has been completed with.
  'cleanup-all':
        Delete all snapshots created by $my_name.
  'dsync'|'diff-sync':
        Create a new snapshot for all snapper configs found in snapraid config
        file, do a snapraid diff, then sync. Implies --interactive option for
        the sync operation.
  'list'|'ls':
        Run snapper ls for all snapper configs found in snapraid config file.
        If an argument is given, also list which snapshots in each config were
        identified as having snapper userdata key equal to the argument.
  'resume':
        Resume an interrupted sync, using the same set of snapshots.
  'rollback':
        Run snapper rollback in all snapper configs using the snapshots from
        the last successful sync (or another snapshot if the -u or -U option
        is specified). WARNING: Do not use this command unless you are familiar
        with the snapper rollback command and its effects. Instead consider
        using the undochange command.
  'snapper':
        Run the given snapper command in all configs, unless they are disabled
        by --use-snapshot exampleconfig=0 - for example:
           $my_name -U foo=0 snapper get-config
        would run
           snapper -c "\$i" get-config
        substituting "\$i" for each snapper config matching the snapraid.conf
        file, except foo.
  'undochange':
        Use snapper undochange to revert the array to the state it was in at
        the time of the last successful sync (or another snapshot if the -u or
        -U option is specified), creating pre/post snapshots. Arguments are
        passed through to snapper undochange, including the snapper undochange
        -i option.

Environment variables:

  SNAPRAID_CONFIG_FILE -
        Default location of the snapraid.conf file if -c/--conf option is not
        used. If unset, the default location is the same as with vanilla
        snapraid (/usr/local/etc/snapraid.conf if it exists, otherwise
        /etc/snapraid.conf).
  SNAPRAID_USERDATA_KEY -
        Snapper userdata key that is used to track snapshots. If unset, it
        defaults to $DEFAULT_USERDATA_KEY.
  TMPDIR -
        Directory to create temporary snapraid.conf file in. If unset, it
        defaults to $DEFAULT_TMPDIR.

_EOF_
}

# Add key/value pairs from $1 to snapper_userdata, unless key is
# $snapper_userdata_key
use_snapper_userdata() {
    local key value i
    local -a args
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        key=
        value=
        IFS='=' read -r key value <<< "$i"
        [[ "$key" = "$snapper_userdata_key" ]] ||
            snapper_userdata+=",$key=$value"
    done
}

# Set use_snapshot to $1 for all configs, overriding any previous values
use_snapshot_all() {
    local i
    for i in "${snapper_configs[@]}" ; do
        use_snapshot[$i]="$1"
    done
}

# If use_snapshot[$i] is the empty string for any snapper config, indicating
# that find_snapshots did not find one, display an error message and exit
use_snapshot_check() {
    local i
    for i in "${snapper_configs[@]}" ; do
        if [[ -z "${use_snapshot[$i]}" ]] ; then
            printf '%s: Could not find a snapshot for config %s\n' \
                   "$my_name" "$i" >&2
            exit $EXIT_SNAPSHOT_NOT_FOUND
        fi
    done
}

# For any configs where use_snapshot is undefined, set it to $1
use_snapshot_default() {
    local i
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]:-}" ]] ||
            use_snapshot[$i]="$1"
    done
}

# When running a fix operation, parse the -d/--filter-disk snapraid option if
# specified, and set ${use_snapshot[@]} accordingly
use_snapshot_fix() {
    local disk opt_str snapper_config_name
    local -i configs_found length i
    configs_found=0
    while (($# > 0)) ; do
        disk=
        case $1 in
            --filter-disk=*)
                disk="${1#--filter-disk=}"
                shift ;;
            --filter-disk|-*(["$SNAPRAID_OPTS_NOARG"])d)
                option_requires_argument "$@"
                disk="$2" ;&
            --@(filter|import|plan|older-than|log|start|count|error-limit)) ;&
            --gen-conf)
                shift 2 || shift ;;
            -*)
                opt_str="${1#-}"
                length="${#opt_str}"
                for ((i=0;i<length;i++)) ; do
                    case ${opt_str:$i:1} in
                        d)
                            disk="${opt_str:$((i+1))}" ;&
                        ["$SNAPRAID_OPTS_ARG"])
                            break ;;
                    esac
                done ;;&
            *)
                shift ;;
        esac
        if [[ "$disk" ]] ; then
            snapper_config_name="$(get_snapper_config_name "$disk")"
            if [[ "$snapper_config_name" ]] ; then
                ((++configs_found))
                [[ "${use_snapshot[$snapper_config_name]:-}" ]] ||
                    use_snapshot[$snapper_config_name]=0
            fi
        fi
    done
    if ((configs_found > 0)) ; then
        use_snapshot_default sync
        find_snapshots fix
    fi
    use_snapshot_default 0
}

verbose_command() {
    if ((interactive > 0)) ; then
        interactive_ask "$@" >&2
    elif ((verbose >= 0)) ; then
        printf '%s ' "$@"
        printf '\n'
    fi
}

main "$@"
