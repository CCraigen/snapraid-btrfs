#!/bin/bash -

# Copyright (C) 2017-2019 Alex deBeus

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# bash version 4+ required for associative arrays, coprocesses, and
# ;& and ;;& terminators in case statements
# 4.1+ required for ACL support
if ! { ((BASH_VERSINFO[0] > 4)) ||
        { ((BASH_VERSINFO[0] == 4)) && ((BASH_VERSINFO[1] >= 1)) ; } ; }
then
    echo 'bash version 4.1+ is required to use this script' >&2
    exit 63
fi

readonly DEFAULT_CONFIG_FILE=/etc/snapraid.conf
readonly DEFAULT_TMPDIR=/tmp
readonly DEFAULT_USERDATA_KEY=snapraid-btrfs
readonly E_INTERNAL_ERROR=64
readonly E_INVALID_ARGUMENT=65
readonly E_INVALID_CONFIG=66
readonly E_NO_PERMISSION=67
readonly E_SNAPSHOT_NOT_FOUND=68
readonly E_INTERACTIVE_NO=69
readonly LOWER=abcdefghijklmnopqrstuvwxyz
readonly MY_VERSION='0.9.9+git'
# snapraid short options, sorted by whether or not they accept arguments
readonly SNAPRAID_OPTS_ARG=BCLScdfilop
readonly SNAPRAID_OPTS_NOARG=DEFHLNRUVZaehmqv

set -o errexit
set -o errtrace
set -o functrace
set -o nounset
set -o pipefail
set +o noclobber
set +o noglob
set +o posix
shopt -s extglob
shopt -s extquote
shopt -u nocasematch
# Use lastpipe if available (bash 4.2+) since it's faster,
# but we don't need the behavior
shopt -s lastpipe &> /dev/null || true

# Apply the --pre-post and --no-pre-post command line options
apply_pre_post_options() {
    local i j
    if ((${#pre_post_option[@]} > 0)) ; then
        for i in "${pre_post_option[@]}" ; do
            config_must_exist "$i"
        done
        pre_post_configs=( "${pre_post_option[@]}" )
    else
        pre_post_configs=( "${snapper_configs[@]}" )
    fi
    if ((${#no_pre_post_option[@]} > 0)) ; then
        local -a temp_array
        for i in "${no_pre_post_option[@]}" ; do
            config_must_exist "$i"
            temp_array=()
            for j in "${pre_post_configs[@]}" ; do
                [[ "$j" = "$i" ]] || temp_array+=( "$j" )
            done
            pre_post_configs=( "${temp_array[@]}" )
        done
    fi
}

# Set use_snapshot from comma-separated key=value pairs specified in $1
apply_use_snapshot_option() {
    local -a args
    local config config_using i
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        IFS='=' read -r config config_using <<< "$i"
        config_must_exist "$config"
        use_snapshot[$config]="$config_using"
    done
}

# Sanity checks to run after reading configuration from
# snapraid.conf and snapper list-configs
check_config() {
    # Make sure we found some configs
    if ((${#snapper_configs[@]} == 0)) ; then
        fatal_error $E_INVALID_CONFIG \
            "No snapper configs found for any data drives in $config_file"
    fi
    # We don't want to snapshot the content files. So, check the directories of
    # the content files, and compare their mount points with those of the
    # subvolumes we are snapshotting, to see if any match
    local field1 field2 content_dir content_mount i
    while IFS=$' \t' read -r field1 field2 ; do
        if [[ "$field1" = content ]] ; then
            content_dir="$(dirname -- "$field2")"
            content_mount="$(stat --format=%m -- "$content_dir")"
            for i in "${snapper_configs[@]}" ; do
                if [[ "$content_mount" -ef "${snapper_subvols[$i]}" ]] ; then
                    fatal_error $E_INVALID_CONFIG \
                        "$field2 found in subvolume ${snapper_subvols[$i]}" \
                        " - content files must be in separate subvolume"
                fi
            done
        fi
    done < "$config_file"
    for i in "${snapper_configs[@]}" ; do
        # Check that .snapshots subvolume exists
        if ! is_btrfs_subvolume "${snapper_subvols[$i]}/.snapshots" ; then
            fatal_error $E_INVALID_CONFIG "${snapper_subvols[$i]}/.snapshots" \
                ' is not a valid btrfs subvolume'
        # Check that we have read permission for snapshots
        # Try a snapper ls first in case ACLs need to be refreshed
        elif ! { snapper_ls_sync_acl "$i" &&
                     [[ -r "${snapper_subvols[$i]}/.snapshots" ]] ; }
        then
            fatal_error $E_NO_PERMISSION 'No read permission for ' \
                "${snapper_subvols[$i]}/.snapshots" \
                ' - is SYNC_ACL set in snapper configuration?'
        fi
    done
}

# Sanity checks to run before reading snapraid.conf file
check_config_file() {
    if ! [[ -r "$config_file" ]] ; then
        fatal_error $E_INVALID_ARGUMENT \
            "Could not read snapraid config file at $config_file"
    elif ((verbose > 0)) ; then
        printf 'Using snapraid config file %s\n' "$config_file"
    fi
    # check for trailing newline in snapraid.conf
    # Lack of a trailing newline will cause problems when parsing the config
    # file with read. Therefore, if there is no trailing newline, create a
    # temporary config file with a newline added and use that instead.
    if [[ "$(tail -c 1 "$config_file")" ]] ; then
        if ((verbose >= 0)) ; then
            printf '%s: Warning: No newline at end of %s\n' "$my_name" \
                "$config_file" >&2
        fi
        local new_config_file
        new_config_file="$(mktemp -- "$temp_dir/$my_name.XXXXXX")"
        rm_on_exit+=( "$new_config_file" )
        cat < "$config_file" > "$new_config_file"
        echo >> "$new_config_file"
        config_file="$new_config_file"
    fi
}

# Make sure all external binaries in $@ can be found in $PATH
check_dependencies() {
    while (($# > 0)) ; do
        if ! type "$1" &> /dev/null ; then
            fatal_error $E_INTERNAL_ERROR "Could not find $1 in PATH"
        fi
        shift
    done
}

# Make sure the user hasn't tried to pass through the -c option to snapraid
check_snapraid_arguments() {
    while (($# > 0)) ; do
        case $1 in
            --conf|-*(["$SNAPRAID_OPTS_NOARG"])c*)
                fatal_error $E_INVALID_ARGUMENT \
                    'The -c/--conf option ' \
                    'may not be passed through to snapraid' ;;
        esac
        if snapraid_opt_has_arg "$@" ; then
            shift 2
        else
            shift
        fi
    done
}

cleanup_coproc() {
    eval "${debug_fd:+exec ${debug_fd}>&-}"
    eval "${sed_escape_debug[1]:+exec ${sed_escape_debug[1]}>&-}"
    # shellcheck disable=2154
    # Shellcheck doesn't understand named coprocesses
    # See https://github.com/koalaman/shellcheck/issues/1066
    eval "${sed_escape_debug_PID:+wait $sed_escape_debug_PID}"
    debug_fd=
}

# In each config, delete snapshots with userdata key $snapper_userdata_key
# except use_snapshot[$i], or all such snapshots if use_snapshot[$i]=0
cleanup_snapshots() {
    local i j
    local -i ret=0
    local -i snapper_ret
    local -a snapshots_to_consider
    for i in "${snapper_configs[@]}" ; do
        # skip this config if we couldn't find a synced snapshot
        if [[ -z "${use_snapshot[$i]}" ]] ; then
            if ((verbose >= 0)) ; then
                printf 'No synced snapshot found for config %s, skipping\n' \
                    "$i" >&2
            fi
            continue
        fi
        IFS=' ' read -r -a snapshots_to_consider \
            <<< "$(snapper_ls_wrapper "$i" |
            parse_snapper_ls "$snapper_userdata_key" '' ' ')"
        for j in "${snapshots_to_consider[@]}" ; do
            if [[ "${use_snapshot[$i]}" != "$j" ]] ; then
                verbose_command "$my_snapper" -c "$i" rm "$j"
                snapper_ret=$?
                if ((snapper_ret != 0)) ; then
                    ret=$snapper_ret
                fi
            fi
        done
    done
    return $ret
}

# Check that the user didn't specify a nonexistent snapper config by ensuring
# that a subvolume is set for the config name
config_must_exist() {
    [[ "${snapper_subvols[$1]-}" ]] ||
        fatal_error $E_INVALID_ARGUMENT "Invalid snapper configuration $1"
}

# Calling once creates pre snapshots, calling again creates corresponding post
create_pre_post_snapshots() {
    local -a snapper_cmd
    local i
    for i in "${pre_post_configs[@]}" ; do
        # skip configs where we're using a readonly snapshot
        [[ "${use_snapshot[$i]}" = 0 ]] || continue
        snapper_cmd=( "$my_snapper" -c "$i" create )
        [[ "$snapper_cleanup" ]] &&
            snapper_cmd+=( -c "$snapper_cleanup" )
        snapper_cmd+=( -u "$snapper_userdata" )
        # Check if we've already done a pre snapshot
        if [[ "${pre_snapshot[$i]-}" ]] ; then
            # We've already done pre snapshots, so create corresponding post
            if [[ "$snapper_description" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "$my_name post-$1" )
            fi
            snapper_cmd+=( -t post --pre-number "${pre_snapshot[$i]}" )
            "${snapper_cmd[@]}" || true
        else
            # We haven't created pre snapshots yet, so create them and store
            # the snapshot numbers from snapper -p option in ${pre_snapshot[@]}
            if [[ "$snapper_description" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "$my_name pre-$1" )
            fi
            snapper_cmd+=( -t pre -p )
            pre_snapshot[$i]="$("${snapper_cmd[@]}")"
        fi
    done
}

# display current state of variables
# DEBUG is trapped in enable_debug_mode()
debug_trap() {
    local -r div='----------------------------------------'
    printf '%s\n%s: %s%s\n%s\n' "$div" "$1" "$3" "$2" "$div"
    shift 3
    printf '%s' 'set -- '
    (($# > 0)) && printf '%q ' "$@"
    echo
    # shellcheck disable=2046
    IFS= declare -p $(declare-p_vars_debug)
    printf '%s\n' "$div"
} >&"$debug_fd"

# get variable names to pass as arguments to declare -p
declare-p_vars() {
    while (($# > 0)) ; do
        declare -p | declare-p_vars_awk "$1"
        shift
    done
}

declare-p_vars_awk() {
    awk -f <(cat <<_EOF_
BEGIN {
    FS = "[ \t=]+"
    ORS = " "
}
/^declare -[-Aair]+ $1/ {
    print \$3
}
_EOF_
            )
}

declare-p_vars_debug() {
    declare-p_vars "([$LOWER]|BASH|MY_|(FUNCNAME|PIPESTATUS)=)"
}

declare-p_vars_shell() {
    declare-p_vars "([$LOWER]|LOWER=|(E|MY|SNAPRAID)_)"
}

# start interactive shell in context of script,
# with variables and functions exported
do_shell() (
    # unset variables that will be invalid
    trap - DEBUG
    unset -v debug_fd sed_escape_debug sed_escape_debug_PID
    # shellcheck disable=2030
    rm_on_exit=()
    local funcs vars
    # shellcheck disable=2046
    vars="$(IFS= declare -p $(declare-p_vars_shell))"
    funcs="$(declare -F | awk -v ORS=' ' "/^declare -f [$LOWER]/{print \$3}")"
    export BASHOPTS SHELLOPTS funcs vars
    # shellcheck disable=2086,2163
    IFS= export -f $funcs
    set +o errexit
    set +o nounset
    exec "$BASH" --rcfile \
        <(cat <<'_EOF_'
[[ -e "$HOME/.bashrc" ]] && source "$HOME/.bashrc"
eval "$vars"
IFS= export -fn $funcs
export -n BASHOPTS SHELLOPTS
unset -v funcs vars
exit() {
    printf 'Hooked exit command with status %s\n' "${1:-$?}"
    printf 'Use quit to exit the %s interactive shell\n' "$my_name"
}
quit() {
    command exit "${@:-0}"
}
vars() {
    IFS= declare -p $(declare-p_vars_debug)
}
trap 'exit_trap' EXIT
if ((verbose >= 0)) ; then
    cat <<__EOF__
Started bash session in $my_name context.
Commands:
    quit - exit the interactive shell
    vars - display variable values
__EOF__
fi
_EOF_
         ) -O extglob -i -s "$@"
)

# run the specified snapper command on each config
do_snapper() {
    local i
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        verbose_command "$my_snapper" -c "$i" "$@"
    done
}

# Set DEBUG trap to display variables with each command
enable_debug_mode() {
    [[ "${debug_fd-}" ]] && cleanup_coproc
    coproc sed_escape_debug {
        sed -e $'s/\e/\e[7m\\\\e\e[0m/g' \
            -e $'s/\r/\e[7m\\\\r\e[0m/g' \
            -e $'s/\t/\e[7m\\\\t\e[0m/g'
    } >&"${DEBUG_FD:-2}"
    exec {debug_fd}<&"${sed_escape_debug[1]}"
    # shellcheck disable=1004
    trap 'debug_trap "$LINENO" "$BASH_COMMAND" \
        "${FUNCNAME[0]:+${FUNCNAME[0]}(): }" "$@"' DEBUG
}

# Intended to be called by ERR trap. Accepts the following arguments:
# $1 - Line number where ERR condition occurred
# $2 - Command that caused the ERR condition
# $3 - Exit status that caused the ERR condition
err_trap() {
    trap - DEBUG
    printf '%s: %s: %s failed%s\n' "$my_name" "${1:-0}" \
        "${2:-unknown command}" "${3:+ with exit status $3}"
    local func line script
    local -i frame=0
    echo 'Call stack:'
    while IFS=' ' read -r line func script ; do
        printf '%s: %s: %s\n' "$script" "$func" "$line"
    done < <(while caller $frame ; do ((++frame)) ; done)
    exit "${3:-$E_INTERNAL_ERROR}"
} >&2

# Intended to be called by EXIT trap
# Removes rm_on_exit if nonempty and cleans up coprocess if necessary
exit_trap() {
    # shellcheck disable=2031
    if ((${#rm_on_exit[@]} > 0)) ; then
        rm -f -- "${rm_on_exit[@]}" || true
    fi
    trap - DEBUG
    cleanup_coproc
    return 0
}

# $1 - exit status to exit with
# $2,$3,... - error message to print as $* after shifting
fatal_error() {
    local -i errno="${1-}"
    if ((errno < 1)) || ((errno > 255)) ; then
        printf 'fatal_error called with invalid exit status %s\n' "${1-(none)}"
        errno="$E_INTERNAL_ERROR"
    fi
    shift || true
    IFS= printf '%s: %s\n' "$my_name" "${*:-fatal error}"
    case $errno in
        "$E_INVALID_ARGUMENT")
            printf 'Use %s -h for help\n' "$my_name" ;;
    esac
    exit "$errno"
} >&2

# compare output of snapper list-configs with snapraid.conf
find_configs() {
    local config subvol subvol_grep i
    # grep ERE matching data line up to the point where the path starts
    local -r data_line=$'[ \t]*(data|disk)[ \t]+[^ \t]+[ \t]+'
    while IFS='|' read -r config subvol ; do
        # Remove padding spaces
        config="${config%%*( )}"
        subvol="${subvol##*( )}"
        subvol="${subvol%%*( )}"
        # escape grep ERE metacharacters in subvolume path
        # shellcheck disable=2001
        # https://github.com/koalaman/shellcheck/issues/1768
        subvol_grep="$(sed 's/[].*+?{}()|$^\[]/\\&/g' <<< "$subvol")"
        # allow trailing slash and/or \r character
        if grep -Ex "$data_line$subvol_grep"$'[/]?[\r]?' \
                "$config_file" > /dev/null
        then
            snapper_configs+=( "$config" )
            snapper_subvols[$config]="$subvol"
        fi
    done < <("$my_snapper" list-configs | tail -n +3)
    if ((verbose >= 0)) ; then
        echo 'Snapper configs found:'
        for i in "${snapper_configs[@]}" ; do
            printf '%s %s\n' "$i" "${snapper_subvols[$i]}"
        done
    fi
}

# replace keywords in use_snapshot with actual snapshot numbers, or with the
# empty string if a snapshot matching the keyword cannot be found
find_snapshots() {
    local snapper_create_opts=( -u "$snapper_userdata" )
    [[ "$snapper_cleanup" ]] &&
        snapper_create_opts+=( -c "$snapper_cleanup" )
    if [[ "$snapper_description" ]] ; then
        snapper_create_opts+=( -d "$snapper_description" )
    else
        snapper_create_opts+=( -d "$my_name $1" )
    fi
    local i
    for i in "${snapper_configs[@]}" ; do
        case ${use_snapshot[$i]} in
            0|'')
                continue ;;
            diff)
                use_snapshot[$i]="$(snapper_ls_wrapper "$i" |
                    parse_snapper_ls "$snapper_userdata_key" diff |
                    tail -n 1)" ;;
            last)
                use_snapshot[$i]="$(snapper_ls_wrapper "$i" |
                    parse_snapper_ls "$snapper_userdata_key" |
                    tail -n 1)" ;;
            new)
                use_snapshot[$i]="$("$my_snapper" -c "$i" create -p \
                    "${snapper_create_opts[@]}")"
                if ((verbose > 0)) ; then
                    printf 'Created new snapshot %s for config %s\n' \
                        "${use_snapshot[$i]}" "$i"
                fi ;;
            res)
                use_snapshot[$i]="$(snapper_ls_wrapper "$i" |
                    parse_snapper_ls "$snapper_userdata_key" syncing |
                    tail -n 1)" ;;
            sync)
                use_snapshot[$i]="$(snapper_ls_wrapper "$i" |
                    parse_snapper_ls "$snapper_userdata_key" synced |
                    tail -n 1)" ;;
            +([0123456789]))
                if ! { snapper_ls_wrapper "$i" |
                           parse_snapper_ls |
                           grep -Fx "${use_snapshot[$i]}" > /dev/null ; }
                then
                    use_snapshot[$i]=
                fi ;;
            *)
                fatal_error $E_INVALID_ARGUMENT \
                    'Could not understand snapshot selection ' \
                    "${use_snapshot[$i]} for config $i" ;;
        esac
        if ((verbose > 0)) && [[ "${use_snapshot[$i]}" ]] ; then
            printf 'Using snapshot %s for config %s\n' \
                "${use_snapshot[$i]}" "$i"
        fi
    done
}

# generate sed script to replace subvolume paths with corresponding snapshots
# (and pool directory, if --pool-dir is specified) and run it on snapraid.conf
generate_temp_snapraid_conf() {
    local match_line new_path sed_find sed_replace i
    local sed_exps=()
    # sed BRE matching data line up to the point where the path starts
    local -r data_line=$'^[ \t]*data[ \t]\{1,\}[^ \t]\{1,\}[ \t]\{1,\}'
    if [[ "$pool_dir" ]] ; then
        # shellcheck disable=2016
        sed_exps+=( $'/^[ \t]*pool[ \t]\{1,\}/d'
                    '$apool '"$pool_dir" )
    fi
    for i in "${snapper_configs[@]}" ; do
        if [[ "${use_snapshot[$i]}" != 0 ]] ; then
            new_path="${snapper_subvols[$i]}/.snapshots/"
            new_path+="${use_snapshot[$i]}/snapshot"
            if ! is_btrfs_subvolume "$new_path" ; then
                fatal_error $E_SNAPSHOT_NOT_FOUND "Invalid snapshot $new_path"
            elif ! [[ -r "$new_path" ]] ; then
                fatal_error $E_NO_PERMISSION "No read permission for $new_path"
            fi
            # Escape special characters in paths so that they can be
            # passed to sed as literal strings
            sed_find="$(sed 's/[].*$^/\[]/\\&/g' <<< "${snapper_subvols[$i]}")"
            sed_replace="$(sed 's/[&/\]/\\&/g' <<< "$new_path")"
            match_line="$data_line$sed_find"$'[/]\{0,1\}[\r]\{0,1\}$'
            # also match the deprecated token 'disk' using separate sed
            # expression to avoid depending on the GNU extension \|
            sed_exps+=( "/$match_line/s/$sed_find/$sed_replace/"
                        "/${match_line/data/disk}/s/$sed_find/$sed_replace/" )
        fi
    done
    if ((${#sed_exps[@]} == 0)) ; then
        cat < "$config_file"
    else
        sed -f <(printf '%s\n' "${sed_exps[@]}") -- "$config_file"
    fi
}

# given the snapraid.conf name for a disk (e.g. d1 in disk d1 /foo/bar),
# find the corresponding snapper config name, if any
get_snapper_config_name() {
    local subvol=
    local field1 field2 field3 i
    while IFS=$' \t' read -r field1 field2 field3 ; do
        case $field1 in
            data|disk)
                if [[ "$field2" = "$1" ]] ; then
                    subvol="${field3%$'\r'}"
                    subvol="${subvol%/}"
                    break
                fi ;;
        esac
    done < "$config_file"
    [[ "$subvol" ]] || return
    for i in "${snapper_configs[@]}" ; do
        if [[ "${snapper_subvols[$i]}" = "$subvol" ]] ; then
            printf '%s\n' "$i"
            break
        fi
    done
}

get_snapper_version() {
    "$my_snapper" --version | sed -n '1s/^[^0123456789]*//p'
}

interactive_ask() {
    echo 'About to run the following command:'
    print_command "$@"
    local choice
    while true ; do
        read -r -p 'Do it [Y/N]? ' choice
        case $choice in
            [Yy]?([Ee][Ss]))
                break ;;
            [Nn]?([Oo]))
                exit $E_INTERACTIVE_NO ;;
            *)
                echo 'Invalid choice. Please enter y or n.' ;;
        esac
    done
} >&2

invalid_argument() {
    fatal_error $E_INVALID_ARGUMENT "Invalid argument $1"
}

# Returns:
# 0 if $1 is a btrfs subvolume
# 1 if $1 is an "empty subvolume" inside a snapshot
# 2 if $1 is an ordinary directory
# 3 if $1 is not a directory
# 4 if we couldn't determine the inode number with stat
is_btrfs_subvolume() {
    [[ -d "$1" ]] || return 3
    case $(stat --format=%i -- "$1") in
        256)
            return 0 ;;
        2)
            return 1 ;;
        '')
            return 4 ;;
        *)
            return 2 ;;
    esac
}

main() {
    check_dependencies awk basename cat dirname grep mktemp rm sed stat tail

    # Declare "global" variables as local to main since they will be
    # accessible from any functions called from main
    # These variables are set during processing of command line arguments and
    # snapraid/snapper configurations and are initialized to defaults here

    # snapraid config file location
    local config_file="${SNAPRAID_CONFIG_FILE:-$DEFAULT_CONFIG_FILE}"
    # fd to send debug output to if -x/--debug is enabled
    local debug_fd=
    # indicates whether the -i/--interactive option has been enabled
    local -i interactive=0
    # filename of script determined at runtime
    local my_name
    my_name="$(basename -- "${BASH_SOURCE[0]}")"
    # snapper/snapraid commands to use, can be specified with the
    # --snapper-path and --snapraid-path command line options
    local my_snapper=snapper
    local my_snapraid=snapraid
    # --pool-dir option argument
    local pool_dir=
    # list of snapper configs to create pre/post snapshots for
    local pre_post_configs=()
    # --pre-post option argument, after splitting
    local pre_post_option=()
    # --no-pre-post option argument, after splitting
    local no_pre_post_option=()
    # names of temp files to rm upon exiting
    local rm_on_exit=()
    # snapper cleanup algorithm to specify when creating new snapshots
    local snapper_cleanup=
    # names of all snapper configs that match snapraid.conf
    local snapper_configs=()
    # description to specify to snapper when creating new snapshots
    local snapper_description=
    # variable to be set if snapper ls supports --disable-used-space
    # (version 0.6.0 or newer)
    local snapper_ls_quota_support=
    # variable to be set if snapper ls supports --disable-used-space and
    # --used-space option was not specified
    local snapper_ls_quota_support_disable=
    # snapper userdata key that will be specified to track created snapshots
    # can be changed by setting the SNAPRAID_USERDATA_KEY environment variable
    local \
        snapper_userdata_key="${SNAPRAID_USERDATA_KEY:-$DEFAULT_USERDATA_KEY}"
    # default userdata to set for newly created snapshots
    # additional userdata can be specified with the --snapper-userdata option
    local snapper_userdata="$snapper_userdata_key=created"
    # directory to create temporary snapraid.conf file in
    local temp_dir="${TMPDIR:-$DEFAULT_TMPDIR}"
    must_be_writable_dir "$temp_dir" 'is TMPDIR set correctly?'
    # --use-filter-disk option argument
    local -i use_filter_disk=0
    # --use-snapshot-all option argument
    local use_snapshot_all_option=
    # --use-snapshot option argument
    local use_snapshot_option=
    # variable to be set if --used-space option is specified
    local -i used_space_option=0
    # controls verbosity, incremented by -v/--verbose or
    # decremented by -q/--quiet command line option
    local -i verbose=0
    # These associative arrays are indexed by snapper configs in the
    # snapper_configs array, and hold the following data:
    # pre_snapshot - number of pre snapshot created, to use when creating post
    # snapper_subvols - subvolume corresponding to the snapper config
    # use_snapshot - which snapshot should be used for the snapper config
    local -A pre_snapshot snapper_subvols use_snapshot

    trap 'err_trap $LINENO "$BASH_COMMAND" $?' ERR
    trap 'exit_trap' EXIT

    # Iterate through command line arguments and process snapraid-btrfs options
    # until a command is reached, then run the specified command, passing
    # through any remaining command line arguments appearing after the command
    local opt_str
    local -i length i
    local command=
    while (($# > 0)) ; do
        case $1 in
            # matching a snapraid command means option processing is complete
            # and any further options will be passed through to snapraid
            check) ;&
            diff) ;&
            fix) ;&
            pool) ;&
            resume) ;&
            scrub) ;&
            ?(diff-|d)sync) ;&
            touch) ;&
            # Option processing is also complete for other commands which
            # accept arguments
            ls|list) ;&
            shell) ;&
            snapper) ;&
            undochange)
                break ;;
            # support options specified either before or after the command
            # for commands which don't invoke snapraid or accept argument
            cleanup?(-all)) ;&
            config) ;&
            create) ;&
            rollback)
                if [[ -z "$command" ]] ; then
                    command="$1"
                    shift
                else
                    invalid_argument "$1 to command $command"
                fi ;;
            # snapraid-btrfs options specified before command
            # long form options that don't take arguments
            --debug) ;&
            --help) ;&
            --interactive) ;&
            --quiet) ;&
            --use-filter-disk) ;&
            --used-space) ;&
            --verbose) ;&
            --version)
                set_option "$1"
                shift ;;
            # long form options that require arguments
            --conf?(=*)) ;&
            --cleanup?(=*)) ;&
            --description?(=*)) ;&
            --pool-dir?(=*)) ;&
            --?(no-)pre-post?(=*)) ;&
            --snapper-@(path|userdata)?(=*)) ;&
            --snapraid-path?(=*)) ;&
            --use-snapshot?(-all)?(=*))
                # allow POSIX --argument option or --argument=option formats
                opt_str="${1%%=*}"
                if [[ "$opt_str" = "$1" ]] ; then
                    set_option "$opt_str" "${2-}"
                    shift 2 || shift
                else
                    set_option "$opt_str" "${1#$opt_str=}"
                    shift
                fi ;;
            --*)
                invalid_argument "$1" ;;
            # allow POSIX-style combining of short options
            -*)
                opt_str="${1#-}"
                length="${#opt_str}"
                for ((i=0;i<length;i++)) ; do
                    case ${opt_str:$i:1} in
                        # short options that don't take arguments
                        [Vhiqvx])
                            set_option "-${opt_str:$i:1}"
                            if ((i == length-1)) ; then
                                shift
                            fi ;;
                        # short options that require arguments
                        [CUcdu])
                            if ((i == length-1)) ; then
                                set_option "-${opt_str:$i:1}" "${2-}"
                                shift 2 || shift
                            else
                                set_option "-${opt_str:$i:1}" \
                                    "${opt_str:$((i+1))}"
                                shift
                                break
                            fi ;;
                        *)
                            invalid_argument "-${opt_str:$i:1}" ;;
                    esac
                done ;;
            *)
                invalid_argument "$1" ;;
        esac
    done
    [[ "${command-}" ]] && set -- "$command"
    if (($# > 0)) ; then
        # These variables are intended to be truly local, unlike the "global"
        # variables declared as local to main(), so we unset them when done
        unset -v command length opt_str i
        setup_config "$@"
        run_command "$@"
    else
        fatal_error $E_INVALID_ARGUMENT "No command specified"
    fi
}

# set $snapper_userdata_key userdata key to $1
modify_userdata() {
    local i
    local -i ret=0
    local -i snapper_ret
    for i in "${snapper_configs[@]}" ; do
        "$my_snapper" -c "$i" modify -u "$snapper_userdata_key=$1" \
            "${use_snapshot[$i]}" && true
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    return $ret
}

must_be_executable() {
    [[ -x "$1" ]] ||
        fatal_error $E_INVALID_ARGUMENT "$1 is not an executable file"
}

must_be_writable_dir() {
    [[ -d "$1" ]] ||
        fatal_error $E_INVALID_ARGUMENT "$1 is not a directory${2:+ - $2}"
    [[ -w "$1" ]] ||
        fatal_error $E_NO_PERMISSION "No write permission for $1${2:+ - $2}"
}

# call this to make sure $2 is defined when user specifies option requring it
option_requires_argument() {
    [[ "${2-}" ]] ||
        fatal_error $E_INVALID_ARGUMENT "Option $1 requires an argument"
}

# use awk to parse piped snapper ls output and find snapshot numbers
# matching the specified userdata constraints:
# if $1 and $2 are nonempty, match snapshots with userdata key $1=$2
# else if $1 is nonempty, match snapshots with userdata key $1 defined
# else match all snapshots
# if multiple snapshots match, separate their numbers with $3, or
# if $3 is undefined, separate the snapshot numbers with newlines
parse_snapper_ls() {
    awk -F '|' \
        -v key="${1-}" \
        -v value="${2-}" \
        -v ORS="${3:-$'\n'}" \
        -f <(cat <<'_EOF_'
# read column titles in header, so as to work with different versions of
# snapper that reorder columns
NR==1 {
    for (i=1;i<=NF;i++) {
        # remove padding spaces, then store column number indexed by title
        gsub(/[ ]+/,"",$i)
        column[$i] = i
    }
    # check to make sure we found columns labelled "#" and "Userdata"
    if (column["#"] == "" || column["Userdata"] == "") {
        printf("error: expected snapper ls column names not found\n",
               "/dev/stderr")
        exit 1
    }
}
# snapshot data begins on line 3
NR>=3 {
    # remove nonnumeric characters (padding spaces, mount status) from #
    gsub(/[^0123456789]+/,"",$column["#"])
    if (key == "") {
        # match all snapshots
        print $column["#"]
    } else {
        # split userdata column into key=value pairs in case
        # multiple userdata keys are defined for a snapshot
        split($column["Userdata"],u,",")
        # construct a new array v where the keys are the values from u
        for (i in u) {
            # remove padding spaces
            gsub(/^[ ]+/,"",u[i])
            gsub(/[ ]+$/,"",u[i])
            if (value == "") {
                # We don't care about the value of the userdata key, so
                # split key=value pairs and store only the key as a key in v
                split(u[i],w,"=")
                v[w[1]]
            } else {
                # We care about both halves of the userdata key=value
                # pair, so store the whole key=value string as a key in v
                v[u[i]]
            }
        }
        # find and print our matches
        if (value == "") {
            if (key in v) {
                print $column["#"]
            }
        } else {
            if (key "=" value in v) {
                print $column["#"]
            }
        }
        # Wipe v so one match doesn't result in matching all subsequent lines
        # delete v only works in gawk
        split("",v," ")
    }
}
_EOF_
            )
}

print_command() {
    printf '%q ' "$@"
    echo
}

print_version() {
    cat <<_EOF_
snapraid-btrfs $MY_VERSION
Copyright (C) 2017-2019 Alex deBeus
License GPLv3+: GNU GPL version 3 or later <https://gnu.org/licenses/gpl.html>
This is free software; you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
_EOF_
}

# Run the command given in $1
run_command() {
    case $1 in
        # Implementation of commands that don't invoke snapraid
        cleanup?(-all))
            cleanup_snapshots ;;
        config)
            generate_temp_snapraid_conf ;;
        ls|list)
            shift
            snapper_ls "$@" ;;
        rollback)
            snapper_rollback ;;
        shell)
            shift
            do_shell "$@" ;;
        snapper)
            shift
            do_snapper "$@" ;;
        undochange)
            shift
            snapper_undochange "$@" ;;
        # Implementation of commands that invoke snapraid
        check|diff|fix|pool|scrub|sync|touch)
            run_snapraid "$@" && true ;;
        resume)
            shift
            run_snapraid sync "$@" && true ;;
        @(d|diff-)sync)
            shift
            local -i diff_ret
            run_snapraid diff "$@" && true
            diff_ret=$?
            # snapraid diff returns 2 if a sync is required
            if ((diff_ret == 2)) ; then
                ((++interactive))
                run_snapraid sync --force-empty "$@" && true
            else
                exit $diff_ret
            fi ;;
    esac
    exit
}

# Returns exit status of snapraid, postfix calls with '&& true' to avoid
# triggering errexit if snapraid's return status is nonzero
run_snapraid() {
    check_snapraid_arguments "$@"
    local -i ret
    local temp_config_file
    temp_config_file="$(mktemp -- "$temp_dir/$my_name.XXXXXX")"
    rm_on_exit+=( "$temp_config_file" )
    generate_temp_snapraid_conf > "$temp_config_file"
    if ((verbose >= 0)) ; then
        echo 'Using snapraid config file:'
        cat < "$temp_config_file"
    fi
    case $1 in
        fix|touch)
            create_pre_post_snapshots "$1" ;;
        sync)
            modify_userdata syncing
            # set up a trap to track whether snapraid sync returned exit status
            # 0 because it completed successfully, or because it was
            # interrupted with ctrl-C, but was able to clean up before exiting
            local -i interrupted=0
            trap '((++interrupted)) ; trap - INT TERM QUIT' INT TERM QUIT ;;
    esac
    # Run snapraid
    verbose_command "$my_snapraid" -c "$temp_config_file" "$@"
    ret=$?
    case $1 in
        fix|touch)
            create_pre_post_snapshots "$1" ;;
        diff)
            # snapraid diff returns 0 if no changes, 2 if sync needed
            if ((ret == 0)) || ((ret == 2)) ; then
                modify_userdata "$1"
            fi ;;
        sync)
            trap - INT TERM QUIT
            # don't mark sync as completed if INT/TERM/QUIT trap was triggered
            if ((ret == 0)) && ((interrupted == 0)) ; then
                modify_userdata synced
            fi ;;
    esac
    return $ret
}

# $1 is option being set, $2 is argument. If no argument,
# $2 can be either undefined or empty
set_option() {
    case $1 in
        --conf) ;&
        --cleanup) ;&
        --description) ;&
        --pool-dir) ;&
        --?(no-)pre-post) ;&
        --snapper-@(path|userdata)) ;&
        --snapraid-path) ;&
        --use-snapshot?(-all)) ;&
        -[CUcdu])
            option_requires_argument "$@" ;;&
        -c|--conf)
            config_file="$2" ;;
        -C|--cleanup)
            snapper_cleanup="$2" ;;
        -d|--description)
            snapper_description="$2" ;;
        -h|--help)
            usage
            exit ;;
        -i|--interactive)
            ((++interactive)) ;;
        -q|--quiet)
            ((--verbose)) || true ;;
        -u|--use-snapshot-all)
            use_snapshot_all_option="$2" ;;
        -U|--use-snapshot)
            use_snapshot_option="$2" ;;
        -v|--verbose)
            ((++verbose)) || true ;;
        -V|--version)
            print_version
            exit ;;
        -x|--debug)
            enable_debug_mode ;;
        --no-pre-post)
            IFS=',' read -r -a no_pre_post_option <<< "$2" ;;
        --pool-dir)
            must_be_writable_dir "$2"
            pool_dir="$2" ;;
        --pre-post)
            IFS=',' read -r -a pre_post_option <<< "$2" ;;
        --snapper-path)
            must_be_executable "$2"
            my_snapper="$2" ;;
        --snapper-userdata)
            use_snapper_userdata "$2" ;;
        --snapraid-path)
            must_be_executable "$2"
            my_snapraid="$2" ;;
        --use-filter-disk)
            ((++use_filter_disk)) ;;
        --used-space)
            ((++used_space_option)) ;;
        *)
            invalid_argument "$1" ;;
    esac
}

# Called immediately after all command line options have been parsed to
# read snapraid configuration file and initialize the arrays local to main()
# which track the configuration
setup_config() {
    check_dependencies "$my_snapper" "$my_snapraid"
    readonly my_snapper my_snapraid
    if version_is_at_least "$(get_snapper_version)" 0.6.0 ; then
        snapper_ls_quota_support=1
        ((used_space_option == 0)) && snapper_ls_quota_support_disable=1
    fi
    check_config_file
    find_configs
    check_config
    [[ "$use_snapshot_option" ]] &&
        apply_use_snapshot_option "$use_snapshot_option"
    local i
    if [[ "$use_snapshot_all_option" ]] ; then
        for i in "${snapper_configs[@]}" ; do
            [[ "${use_snapshot[$i]-}" ]] ||
                use_snapshot[$i]="$use_snapshot_all_option"
        done
    fi
    apply_pre_post_options
    setup_use_snapshot "$@"
}

# Initialize ${use_snapshot[@]} with command-specific defaults
setup_use_snapshot() {
    case $1 in
        cleanup)
            use_snapshot_all sync ;;&
        cleanup-all|touch)
            use_snapshot_all 0 ;;&
        config)
            use_snapshot_default last ;;&
        check|pool|rollback|scrub|undochange)
            use_snapshot_default sync ;;&
        create|diff|?(d|diff-)sync)
            use_snapshot_default new ;;&
        fix)
            use_snapshot_fix "$@" ;;&
        resume)
            use_snapshot_default res ;;&
        shell|snapper)
            use_snapshot_default '' ;;&
        !(cleanup-all|ls|list|snapper|touch))
            find_snapshots "$1" ;;&
        !(cleanup?(-all)|ls|list|shell|snapper|touch))
            use_snapshot_check ;;
    esac
}

# Do a snapper ls in all configs, and if argument(s) are specified,
# additionally identify which snapshots we found with userdata
# key $snapper_userdata_key matching the arguments
snapper_ls() {
    local snapshot_list i j
    for i in "${snapper_configs[@]}" ; do
        snapshot_list="$(snapper_ls_wrapper "$i")"
        printf '\n%s %s\n%s\n' "$i" "${snapper_subvols[$i]}" "$snapshot_list"
        for j in "$@" ; do
            printf 'Snapshots with userdata key %s=%s:\n' \
                "$snapper_userdata_key" "$j"
            parse_snapper_ls "$snapper_userdata_key" "$j" ' ' \
                <<< "$snapshot_list"
            echo
        done
    done
    echo
}

# Run snapper ls &> /dev/null on config $1 to sync ACLs, using
# --disable-used-space option if supported by snapper version in use
snapper_ls_sync_acl() {
    "$my_snapper" -c "$1" ls \
        "${snapper_ls_quota_support:+--disable-used-space}" &>/dev/null
}

# Run snapper ls on config $1, using --disable-used-space option if supported
# by snapper version in use and if --used-space option wasn't specified
snapper_ls_wrapper() {
    "$my_snapper" -c "$1" ls \
        "${snapper_ls_quota_support_disable:+--disable-used-space}"
}

# Run snapper rollback in each snapper config
snapper_rollback() {
    local i
    local -i ret=0
    local -i snapper_ret
    local snapper_rollback_opts=( -u "$snapper_userdata" )
    [[ "$snapper_cleanup" ]] ||
        snapper_rollback_opts+=( -c "$snapper_cleanup" )
    if [[ "$snapper_description" ]] ; then
        snapper_rollback_opts+=( -d "$snapper_description" )
    else
        snapper_rollback_opts+=( -d "$my_name rollback" )
    fi
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        verbose_command "$my_snapper" -c "$i" rollback \
            "${snapper_rollback_opts[@]}" "${use_snapshot[$i]}"
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    return $ret
}

# Run snapper undochange in each snapper config to revert to the state at the
# time ${use_snapshot[$i]} was created, creating before and after snapshots
snapper_undochange() {
    local i
    local -i ret=0
    local -i snapper_ret
    local undochange_files=()
    local undochange_opts=()
    create_pre_post_snapshots undochange
    # ensure that -i option, if specified, appears before snapshots
    # and any other arguments specified (except --) appear after snapshots
    while (($# > 0)) ; do
        case $1 in
            --)
                shift
                break ;;
            -i|--input)
                if (($# > 1)) ; then
                    undochange_opts+=( "$1" "$2" )
                    shift 2
                else
                    undochange_files+=( "$1" )
                    shift
                fi ;;
            *)
                undochange_files+=( "$1" )
                shift ;;
        esac
    done
    undochange_files+=( "$@" )
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        verbose_command "$my_snapper" -c "$i" undochange \
            "${undochange_opts[@]}" "${use_snapshot[$i]}..0" -- \
            "${undochange_files[@]}"
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    create_pre_post_snapshots undochange
    return $ret
}

# returns 0 if $2 is an argument to $1, and 1 if not
snapraid_opt_has_arg() {
    if (($# < 2)) ; then
        return 1
    fi
    case $1 in
        # snapraid long-form options that require arguments
        --count) ;&
        --error-limit) ;&
        --filter?(-disk)) ;&
        --gen-conf) ;&
        --import) ;&
        --log) ;&
        --older-than) ;&
        --percentage) ;&
        --plan) ;&
        # snapraid short-form options that require arguments
        -*(["$SNAPRAID_OPTS_NOARG"])["$SNAPRAID_OPTS_ARG"])
            return 0 ;;
    esac
    return 1
}

# if snapshot not found for a config, prompt the user to choose a different one
snapshot_not_found() {
    local choice snapshot_list
    printf '%s: Snapshot not found for config %s at %s\n' "$my_name" "$1" \
        "${snapper_subvols[$1]}"
    if ((verbose < 0)) ; then
        exit $E_SNAPSHOT_NOT_FOUND
    else
        snapshot_list="$(snapper_ls_wrapper "$1")"
        printf '%s\n' "$snapshot_list"
    fi
    while true ; do
        read -r -p 'Enter a snapshot (0 for none, n for new, q to quit): ' \
            choice
        case $choice in
            [Qq]?([Uu][Ii][Tt]))
                exit $E_INTERACTIVE_NO ;;
            [Nn]?([Ee][Ww]))
                use_snapshot[$1]=new
                find_snapshots 'interactive prompt'
                break ;;
            +([0123456789]))
                if [[ "$choice" = 0 ]] ||
                       { parse_snapper_ls <<< "$snapshot_list" |
                             grep -Fx "$choice" > /dev/null ; }
                then
                    use_snapshot[$1]="$choice"
                    break
                else
                    printf 'Snapshot %s not found\n' "$choice"
                fi ;;
            *)
                printf 'Invalid selection %s\n' "$choice" ;;
        esac
    done
} >&2

usage() {
    cat <<_EOF_
Usage: $my_name [options] <command> [arguments]

Arguments appearing after the command are passed through to snapraid, while
the following options appearing before the command are interpreted by
$my_name:

  -h, --help                    Show this help
  -V, --version                 Show version info
  -c, --conf FILE               Specify location of snapraid config file
                                (default $DEFAULT_CONFIG_FILE)
  -C, --cleanup ARG             Specify snapper cleanup algorithm to set for
                                any snapshots created (default none)
  -d, --description ARG         Specify snapper description to set for any
                                snapshots created
  -i, --interactive             Ask before running snapraid or any potentially
                                destructive snapper commands (when using the
                                cleanup(-all), rollback, or undochange
                                commands)
  -q, --quiet                   Only show snapraid/snapper output and errors
  -u, --use-snapshot-all ARG    Use one of the following arguments:
                                    diff - Use last snapshot a diff was
                                           completed with
                                    last - Use last snapshots created
                                    new  - Create new snapshots
                                    res  - Resume using snapshots from an
                                           interrupted sync
                                    sync - Use last snapshots a successful sync
                                           was completed with
                                or specify the snapshot number (0 for the live
                                filesystem, following snapper syntax)
                                Default is:
                                    'new' for diff|dsync|sync
                                    'last' for config
                                    'res' for resume
                                    'sync' for all other readonly commands
  -U, --use-snapshot ARG        Specify snapshots to use for specific snapper
                                configurations, using the snapper config name
                                followed by an equals sign. Multiple
                                configurations should be separated by commas,
                                e.g. 'config1=5,config2=last'. Overrides -u
  -v, --verbose                 Increase verbosity of output
  -x, --debug                   Enable debugging output
  --no-pre-post ARG             Don't create pre/post snapshots for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
  --pool-dir DIR                Create pool symlinks in DIR (defaults to
                                directory specified in snapraid config file)
  --pre-post ARG                Create pre/post snapshots only for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
  --snapper-path PATH           Path to the snapper executable (defaults to
                                first found in \$PATH)
  --snapper-userdata ARG        Specify snapper userdata to set for any
                                snapshots created in addition to the
                                $my_name attribute, which is set by
                                default and cannot be changed. Argument should
                                be in key=value format accepted by snapper,
                                with multiple keys separated by commas (e.g.
                                key1=value1,key2=value2)
  --snapraid-path PATH          Path to the snapraid executable (defaults to
                                first found in \$PATH)
  --use-filter-disk             If running a fix with the snapraid -d/
                                --filter-disk option, use the live filesystem
                                by default for all disks specified as arguments
                                to the --filter-disk option, and the last
                                synced snapshot for all disks not so specified.
  --used-space                  Don't pass the --disable-used-space option to
                                snapper ls.

  NOTE: The snapraid -c/--conf option will not work unless placed before the
  command, allowing it to be interpreted as a $my_name option. Snapraid
  will be run with a temporary configuration file, generated using whatever
  snapraid.conf file is specified using the $my_name -c/--conf option
  ($DEFAULT_CONFIG_FILE by default).

Commands are either one of the following snapraid commands:
  'check'|'diff'|'pool'|'scrub'|'sync':
        Run the snapraid command given, replacing data drives in snapraid
        config file that have corresponding snapper configs with read-only
        snapshots.
  'fix'|'touch':
        Run the snapraid command given, creating a set of pre/post snapshots
        before and after (for fix, if the snapraid -d/--filter-disk option is
        specified, create pre/post snapshots only for the specified disk(s),
        and use the last-synced snapshot for the rest).

or one of the following $my_name specific commands:
  'config':
        Show the modified snapraid config file that would be used, but don't
        actually run snapraid.
  'create':
        Create a new snapshot for all snapper configs corresponding to data
        drives found in snapraid config file.
  'cleanup':
        Delete all snapshots created by $my_name except the last one a
        successful sync has been completed with.
  'cleanup-all':
        Delete all snapshots created by $my_name.
  'dsync'|'diff-sync':
        Create a new snapshot for all snapper configs found in snapraid config
        file, do a snapraid diff, then sync. Implies --interactive option for
        the sync operation. Uses --force-empty for the sync operation, since
        the diff must be manually approved anyway.
  'list'|'ls':
        Run snapper ls for all snapper configs found in snapraid config file.
        If an argument is given, also list which snapshots in each config were
        identified as having snapper userdata key equal to the argument.
  'resume':
        Resume an interrupted sync, using the same set of snapshots.
  'rollback':
        Run snapper rollback in all snapper configs using the snapshots from
        the last successful sync (or another snapshot if the -u or -U option
        is specified). WARNING: Do not use this command unless you are familiar
        with the snapper rollback command and its effects. Instead consider
        using the undochange command.
  'snapper':
        Run the given snapper command in all configs, unless they are disabled
        by --use-snapshot exampleconfig=0 - for example:
           $my_name -U foo=0 snapper get-config
        would run
           snapper -c "\$i" get-config
        substituting "\$i" for each snapper config matching the snapraid.conf
        file, except foo.
  'undochange':
        Use snapper undochange to revert the array to the state it was in at
        the time of the last successful sync (or another snapshot if the -u or
        -U option is specified), creating pre/post snapshots. Arguments are
        passed through to snapper undochange, including the snapper undochange
        -i option.

Environment variables:
  DEBUG_FD -
        File descriptor to send debug output to if -x/--debug is used. For
        example, running "DEBUG_FD=3 $my_name -xh 3>/tmp/debug" would
        send debug output to /tmp/debug while displaying only the normal output
        of "$my_name -h" on the console. If unset, the default behavior
        is to send debug output to stderr.
  SNAPRAID_CONFIG_FILE -
        Default location of the snapraid.conf file if -c/--conf option is not
        used. If unset, it defaults to $DEFAULT_CONFIG_FILE.
  SNAPRAID_USERDATA_KEY -
        Snapper userdata key that is used to track snapshots. If unset, it
        defaults to $DEFAULT_USERDATA_KEY.
  TMPDIR -
        Directory to create temporary snapraid.conf file in. If unset, it
        defaults to $DEFAULT_TMPDIR.
_EOF_
}

# Add key/value pairs from $1 to snapper_userdata, unless key is
# $snapper_userdata_key
use_snapper_userdata() {
    local key value i
    local -a args
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        IFS='=' read -r key value <<< "$i"
        if [[ "$key" = "$snapper_userdata_key" ]] ; then
            fatal_error $E_INVALID_ARGUMENT \
                "Cannot set reserved userdata key $key"
        else
            snapper_userdata+=",$key=$value"
        fi
    done
}

# Set use_snapshot to $1 for all configs, overriding any previous values
use_snapshot_all() {
    local i
    for i in "${snapper_configs[@]}" ; do
        use_snapshot[$i]="$1"
    done
}

# If use_snapshot[$i] is the empty string for any snapper config, indicating
# that find_snapshots did not find a match, handle the error
use_snapshot_check() {
    local i
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" ]] || snapshot_not_found "$i"
    done
}

# For any configs where use_snapshot is undefined, set it to $1
use_snapshot_default() {
    local i
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]-}" ]] ||
            use_snapshot[$i]="$1"
    done
}

# When running a fix operation, parse the -d/--filter-disk snapraid option if
# specified, and set ${use_snapshot[@]} accordingly
use_snapshot_fix() {
    if [[ "${1-}" = fix ]] ; then
        shift
    else
        fatal_error $E_INTERNAL_ERROR \
            "use_snapshot_fix() called with unexpected arguments"
    fi
    if ((use_filter_disk == 0)) ; then
        use_snapshot_default 0
        return
    fi
    local disk opt_str snapper_config_name
    local -i length i
    local -i configs_found=0
    while (($# > 0)) ; do
        disk=
        case $1 in
            --filter-disk=*)
                disk="${1#--filter-disk=}"
                shift ;;
            --filter-disk|-*(["$SNAPRAID_OPTS_NOARG"])d)
                option_requires_argument "$@"
                disk="$2"
                shift 2 ;;
            -!(-)*)
                opt_str="${1#-}"
                length="${#opt_str}"
                for ((i=0;i<length;i++)) ; do
                    case ${opt_str:$i:1} in
                        d)
                            disk="${opt_str:$((i+1))}" ;&
                        ["$SNAPRAID_OPTS_ARG"])
                            if ((length == i+1)) ; then
                                shift 2 || shift
                            else
                                shift
                            fi
                            break ;;
                    esac
                done ;;
            *)
                fatal_error $E_INTERNAL_ERROR \
                    "error parsing snapraid fix arguments" ;;
        esac
        if [[ "$disk" ]] ; then
            snapper_config_name="$(get_snapper_config_name "$disk")"
            if [[ "$snapper_config_name" ]] ; then
                ((++configs_found))
                [[ "${use_snapshot[$snapper_config_name]-}" ]] ||
                    use_snapshot[$snapper_config_name]=0
            fi
        fi
    done
    if ((configs_found > 0)) ; then
        use_snapshot_default sync
        find_snapshots fix
    fi
    use_snapshot_default 0
}

verbose_command() {
    if ((interactive > 0)) ; then
        interactive_ask "$@"
    elif ((verbose >= 0)) ; then
        print_command "$@"
    fi
    "$@" && true
}

# compares version numbers specified in $1 and $2
# returns 0 if $1 >= $2
version_is_at_least() {
    local -i i
    local -a ver1 ver2
    IFS='.' read -r -a ver1 <<< "$1"
    IFS='.' read -r -a ver2 <<< "$2"
    # if ver1 contains fewer components than ver2, pad with zeroes
    for ((i=${#ver1[@]};i<${#ver2[@]};i++)) ; do
        ver1[i]=0
    done
    # ensure version components are suitable for numeric comparison
    for ((i=0;i<${#ver1[@]};i++)) ; do
        ver1[i]="${ver1[i]##*([^0123456789])}"
        ver1[i]="${ver1[i]%%[^0123456789]*}"
    done
    # iterate through version components until we find the first difference
    for ((i=0;i<${#ver2[@]};i++)) ; do
        if ((ver1[i] > ver2[i])) ; then
            return 0
        elif ((ver1[i] < ver2[i])) ; then
            return 1
        fi
    done
    # if we reach this point, ver1 and ver2 are the same
    # (possibly with ver1 having extra components)
    return 0
}

main "$@"
