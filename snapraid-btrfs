#!/bin/bash -

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# shellcheck disable=SC2221,SC2222
# These warnings don't take ;;& terminators in case statements into account
# see https://github.com/koalaman/shellcheck/issues/1044

readonly DEFAULT_CONFIG_FILE=/etc/snapraid.conf
readonly DEFAULT_TMPDIR=/tmp
readonly DEFAULT_USERDATA_KEY=snapraid-btrfs
readonly E_INTERNAL_ERROR=64
readonly E_INVALID_ARGUMENT=65
readonly E_INVALID_CONFIG=66
readonly E_NO_PERMISSION=67
readonly E_SNAPSHOT_NOT_FOUND=68
readonly E_INTERACTIVE_NO=69
# snapraid short options, sorted by whether or not they accept arguments
readonly SNAPRAID_OPTS_ARG=BCLScdfilop
readonly SNAPRAID_OPTS_NOARG=DEFHLNRUVZaehmqv

# bash version 4+ required for associative arrays, coprocesses, and
# ;& and ;;& terminators in case statements
# 4.1+ required for ACL support
if ! { { ((BASH_VERSINFO[0] == 4)) && ((BASH_VERSINFO[1] >= 1)) ; } ||
           ((BASH_VERSINFO[0] > 4)) ; }
then
    echo 'bash version 4.1+ is required to use this script' >&2
    exit 63
fi

set -o errexit
set -o errtrace
set -o functrace
set -o nounset
set -o pipefail
set +o noclobber
set +o noglob
set +o posix
shopt -s extglob
shopt -s extquote
shopt -u nocasematch
# Use lastpipe if available (bash 4.2+) since it's faster,
# but we don't need the behavior
shopt -s lastpipe &> /dev/null && true

# Apply the --pre-post and --no-pre-post command line options
apply_pre_post_options() {
    local i j
    if ((${#pre_post_option[@]} > 0)) ; then
        for i in "${pre_post_option[@]}" ; do
            config_must_exist "$i"
        done
        pre_post_configs=( "${pre_post_option[@]}" )
    else
        pre_post_configs=( "${snapper_configs[@]}" )
    fi
    if ((${#no_pre_post_option[@]} > 0)) ; then
        local -a temp_array
        for i in "${no_pre_post_option[@]}" ; do
            config_must_exist "$i"
            temp_array=()
            for j in "${pre_post_configs[@]}" ; do
                [[ "$j" = "$i" ]] || temp_array+=( "$j" )
            done
            pre_post_configs=( "${temp_array[@]}" )
        done
    fi
}

# Set use_snapshot from comma-separated key=value pairs specified in $1
apply_use_snapshot_option() {
    local -a args
    local config config_using i
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        IFS='=' read -r config config_using <<< "$i"
        config_must_exist "$config"
        use_snapshot[$config]="$config_using"
    done
}

# substitute for cat that doesn't invoke any external processes
cat_builtin() {
    local buf
    local -i fd
    if [[ "${1-}" ]] ; then
        exec {fd}<"$1"
    else
        exec {fd}<&0
    fi
    IFS= read -r -d '' -u "$fd" buf && true
    eval "exec ${fd}<&-"
    printf '%s' "$buf"
}

check_config() {
    # Make sure we found some configs
    if ((${#snapper_configs[@]} == 0)) ; then
        fatal_error $E_INVALID_CONFIG \
            "No snapper configs found for any data drives in $config_file"
    fi
    # We don't want to snapshot the content files. So, check the directories of
    # the content files, and compare their mount points with those of the
    # subvolumes we are snapshotting, to see if any match
    local field1 field2 content_dir content_mount i
    while IFS=$' \t' read -r field1 field2 ; do
        if [[ "$field1" = content ]] ; then
            content_dir="$(dirname -- "$field2")"
            content_mount="$(stat --format=%m -- "$content_dir")"
            for i in "${snapper_configs[@]}" ; do
                if [[ "$content_mount" -ef "${snapper_subvols[$i]}" ]] ; then
                    fatal_error $E_INVALID_CONFIG \
                        "$field2 found in subvolume ${snapper_subvols[$i]}" \
                        "- content files must be in separate subvolume"
                fi
            done
        fi
    done < "$config_file"
    # Check to make sure the user has permission to access snapshots
    for i in "${snapper_configs[@]}" ; do
        # Try a snapper ls first, in case ACLs need to be refreshed
        if ! { "$my_snapper" -c "$i" ls &> /dev/null &&
                   [[ -r "${snapper_subvols[$i]}/.snapshots" ]] &&
                   is_btrfs_subvolume "${snapper_subvols[$i]}/.snapshots" ; }
        then
            fatal_error $E_NO_PERMISSION 'Could not read subvolume' \
                "${snapper_subvols[$i]}/.snapshots - is SYNC_ACL set?"
        fi
    done
}

check_config_file() {
    if ! [[ -r "$config_file" ]] ; then
        fatal_error $E_INVALID_ARGUMENT \
            "Could not read snapraid config file at $config_file"
    elif ((verbose > 0)) ; then
        printf 'Using snapraid config file %s\n' "$config_file"
    fi
    # check for newline at end of snapraid.conf file
    if [[ "$(tail -c 1 "$config_file")" ]] ; then
        if ((verbose >= 0)) ; then
            printf '%s: Warning: No newline at end of %s\n' "$my_name" \
                "$config_file" >&2
        fi
        local new_config_file
        new_config_file="$(mktemp -- "$temp_dir/$my_name.XXXXXX")"
        rm_on_exit+=( "$new_config_file" )
        must_be_writable "$new_config_file"
        cat_builtin "$config_file" > "$new_config_file"
        printf '\n' >> "$new_config_file"
        config_file="$new_config_file"
    fi
}

# Make sure all external binaries in $@ can be found in $PATH
check_dependencies() {
    local i
    for i in "$@" ; do
        if ! type "$i" &> /dev/null ; then
            fatal_error $E_INTERNAL_ERROR "Could not find $i in PATH"
        fi
    done
}

# Make sure the user hasn't tried to pass through the -c option to snapraid
check_snapraid_arguments() {
    while (($# > 0)) ; do
        case $1 in
            --conf|-*(["$SNAPRAID_OPTS_NOARG"])c*)
                fatal_error $E_INVALID_ARGUMENT \
                    'The -c/--conf option may not be passed through to snapraid'
        esac
        if snapraid_opt_has_arg "$@" ; then
            shift 2
        else
            shift
        fi
    done
}

# In each config, delete snapshots with userdata key $snapper_userdata_key
# except use_snapshot[$i], or all such snapshots if use_snapshot[$i]=0
cleanup_snapshots() {
    local i j
    local -i ret snapper_ret
    local -a snapper_cmd snapshots_to_consider
    ret=0
    for i in "${snapper_configs[@]}" ; do
        # skip this config if we couldn't find a synced snapshot
        if [[ -z "${use_snapshot[$i]}" ]] ; then
            if ((verbose >= 0)) ; then
                printf 'No synced snapshot found for config %s, skipping\n' \
                    "$i" >&2
            fi
            continue
        fi
        IFS=' ' read -r -a snapshots_to_consider \
            <<< "$("$my_snapper" -c "$i" ls |
                parse_snapper_ls "$snapper_userdata_key" '' ' ')"
        for j in "${snapshots_to_consider[@]}" ; do
            if [[ "${use_snapshot[$i]}" != "$j" ]] ; then
                snapper_cmd=( "$my_snapper" -c "$i" rm "$j" )
                verbose_command "${snapper_cmd[@]}"
                "${snapper_cmd[@]}" && true
                snapper_ret=$?
                if ((snapper_ret != 0)) ; then
                    ret=$snapper_ret
                fi
            fi
        done
    done
    return $ret
}

# Check that the user didn't specify a nonexistent snapper config by ensuring
# that a subvolume is set for the config name
config_must_exist() {
    [[ "${snapper_subvols[$1]-}" ]] ||
        fatal_error $E_INVALID_ARGUMENT "Invalid snapper configuration $1"
}

# Calling once creates pre snapshots, calling again creates corresponding post
create_pre_post_snapshots() {
    local -a snapper_cmd
    local i
    for i in "${pre_post_configs[@]}" ; do
        # skip configs where we're using a readonly snapshot
        [[ "${use_snapshot[$i]}" = 0 ]] || continue
        snapper_cmd=( "$my_snapper" -c "$i" create )
        [[ "$snapper_cleanup" ]] &&
            snapper_cmd+=( -c "$snapper_cleanup" )
        snapper_cmd+=( -u "$snapper_userdata" )
        # Check if we've already done a pre snapshot
        if [[ "${pre_snapshot[$i]-}" ]] ; then
            # We've already done pre snapshots, so create corresponding post
            if [[ "$snapper_description" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "$my_name post-$1" )
            fi
            snapper_cmd+=( -t post --pre-number "${pre_snapshot[$i]}" )
            "${snapper_cmd[@]}" && true
        else
            # We haven't created pre snapshots yet, so create them and store the
            # snapshot numbers from snapper -p option in ${pre_snapshot[@]}
            if [[ "$snapper_description" ]] ; then
                snapper_cmd+=( -d "$snapper_description" )
            else
                snapper_cmd+=( -d "$my_name pre-$1" )
            fi
            snapper_cmd+=( -t pre -p )
            pre_snapshot[$i]="$("${snapper_cmd[@]}")"
        fi
    done
}

# display current state of variables
# DEBUG is trapped in enable_debug_mode()
debug_trap() {
    local div line i
    readonly div='----------------------------------------'
    printf '%s\n%s: %s%s\n%s\n' "$div" "$1" "$3" "$2" "$div"
    while IFS= read -r line ; do
        case $line in
            'declare -'[-aAi]' '@(@([[:lower:]]|BASH)*|FUNCNAME|PIPESTATUS))
                printf '%s\n' "$line" ;;
        esac
    done < <(declare -p)
    printf '%s\n' "$div"
} >&"$debug_fd"

# start interactive shell in context of script,
# with variables and functions exported
do_shell() (
    local arrs funcs vars
    arrs="$(declare -p | grep '^declare -[Aa] [[:lower:]]')"
    funcs="$(declare -F | awk '/^declare -f [[:lower:]]/{print $3}')"
    vars="$(declare -p | awk -F '[ =]' \
        '/^declare -[-ir] ([[:lower:]]|(DEFAULT|E|SNAPRAID)_)/{print $3}')"
    # shellcheck disable=SC2086,SC2163
    IFS=$'\n' export BASHOPTS SHELLOPTS arrs funcs vars $vars
    # shellcheck disable=SC2086,SC2163
    IFS=$'\n' export -f $funcs
    set +o errexit
    set +o nounset
    exec "$BASH" --init-file \
        <(cat_builtin <<'_EOF_'
source "$HOME/.bashrc"
eval "$arrs"
IFS=$'\n' export -fn $funcs
IFS=$'\n' export -n BASHOPTS SHELLOPTS $vars
unset -v arrs funcs vars
exit() {
    printf 'Hooked exit command with status %s\n' "${1:-$?}"
    printf 'Use quit to exit the %s interactive shell\n' "$my_name"
}
quit() {
    command exit "${@:-0}"
}
trap 'exit_trap' EXIT
if ((verbose >= 0)) ; then
    printf 'Started bash session in %s context - use quit to exit\n' "$my_name"
fi
if [[ "$debug_fd" ]] ; then
    debug_fd=
    enable_debug_mode
fi
_EOF_
         ) -O extglob -i -s "$@"
)

# run the specified snapper command on each config
do_snapper() {
    local i
    local -a snapper_cmd
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        snapper_cmd=( "$my_snapper" -c "$i" "$@" )
        verbose_command "${snapper_cmd[@]}"
        "${snapper_cmd[@]}"
    done
}

# Set DEBUG trap to display variables with each command
enable_debug_mode() {
    coproc sed_escape_debug {
        sed -e $'s/\e/\e[7m\\\\e\e[0m/g' \
            -e $'s/\r/\e[7m\\\\r\e[0m/g' \
            -e $'s/\t/\e[7m\\\\t\e[0m/g'
    } >&"${DEBUG_FD:-2}"
    exec {debug_fd}<&"${sed_escape_debug[1]}"
    # shellcheck disable=SC1004
    trap 'debug_trap "$LINENO" "$BASH_COMMAND" \
        "${FUNCNAME[0]:+${FUNCNAME[0]}(): }"' DEBUG
}

# Intended to be called by ERR trap. Accepts the following arguments:
# $1 - Line number where ERR condition occurred
# $2 - Command that caused the ERR condition
# $3 - Exit status that caused the ERR condition
err_trap() {
    trap - DEBUG
    printf '%s: %s: %s failed with exit status %s\n%s\n' "$my_name" \
        "${1:-?}" "${2:-unknown command}" "${3:-unknown}" \
        'Stack trace:' >&2
    local func line script
    local -i frame
    frame=0
    while IFS=' ' read -r line func script ; do
        printf '%s: %s: %s\n' "$script" "$func" "$line" >&2
    done < <(while caller $frame ; do ((++frame)) ; done)
    exit "${3:-$E_INTERNAL_ERROR}"
}

# Intended to be called by EXIT trap
# Removes $rm_on_exit if nonempty and cleans up coprocess if necessary
exit_trap() {
    if ((${#rm_on_exit[@]} > 0)) ; then
        rm -f -- "${rm_on_exit[@]}" && true
    fi
    trap - DEBUG
    if [[ "${debug_fd-}" ]] ; then
        eval "exec ${debug_fd}>&- ${sed_escape_debug[1]}>&-"
        # shellcheck disable=SC2086,SC2154
        # Shellcheck doesn't understand named coprocesses
        # See https://github.com/koalaman/shellcheck/issues/1066
        wait $sed_escape_debug_PID
        unset -v debug_fd
    fi
    return 0
}

# $1 - exit status to exit with
# $2,$3,... - error message to print as $* after shifting
fatal_error() {
    local -i errno
    errno="${1:-$E_INTERNAL_ERROR}"
    shift && true
    printf '%s: %s\n' "$my_name" "${*:-fatal error}"
    case $errno in
        $E_INVALID_ARGUMENT)
            printf 'Use %s -h for help\n' "$my_name" ;;
    esac
    exit "$errno"
} >&2

# compare output of snapper list-configs with snapraid.conf
find_configs() {
    local config data_line subvol i
    # grep ERE matching data line up to the point where the path starts
    readonly data_line=$'[ \t]*(data|disk)[ \t]+[^ \t]+[ \t]+'
    while IFS='|' read -r config subvol ; do
        # Remove leading and trailing spaces
        config="${config##*( )}"
        config="${config%%*( )}"
        subvol="${subvol##*( )}"
        subvol="${subvol%%*( )}"
        # allow trailing slash and/or \r character
        if grep -Ex "$data_line$subvol"$'[/]?[\r]?' \
                "$config_file" > /dev/null
        then
            snapper_configs+=( "$config" )
            snapper_subvols[$config]="$subvol"
        fi
    done < <("$my_snapper" list-configs | tail -n +3)
    if ((verbose >= 0)) ; then
        printf 'Snapper configs found:\n'
        for i in "${snapper_configs[@]}" ; do
            printf '%s %s\n' "$i" "${snapper_subvols[$i]}"
        done
    fi
}

# replace keywords in use_snapshot with actual snapshot numbers, or with the
# empty string if a snapshot matching the keyword cannot be found
find_snapshots() {
    local -a snapper_create_opts
    snapper_create_opts=( -u "$snapper_userdata" )
    [[ "$snapper_cleanup" ]] &&
        snapper_create_opts+=( -c "$snapper_cleanup" )
    if [[ "$snapper_description" ]] ; then
        snapper_create_opts+=( -d "$snapper_description" )
    else
        snapper_create_opts+=( -d "$my_name $1" )
    fi
    local i
    for i in "${snapper_configs[@]}" ; do
        case ${use_snapshot[$i]} in
            0|'')
                continue ;;
            diff)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" diff |
                    tail -n 1)" ;;
            last)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" |
                    tail -n 1)" ;;
            new)
                use_snapshot[$i]="$("$my_snapper" -c "$i" create -p \
                    "${snapper_create_opts[@]}")"
                if ((verbose > 0)) ; then
                    printf 'Created new snapshot %s for config %s\n' \
                        "${use_snapshot[$i]}" "$i"
                fi ;;
            res)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" syncing |
                    tail -n 1)" ;;
            sync)
                use_snapshot[$i]="$("$my_snapper" -c "$i" ls |
                    parse_snapper_ls "$snapper_userdata_key" synced |
                    tail -n 1)" ;;
            +([[:digit:]]))
                if ! { "$my_snapper" -c "$i" ls |
                           parse_snapper_ls |
                           grep -Fx "${use_snapshot[$i]}" > /dev/null ; }
                then
                    use_snapshot[$i]=
                fi ;;
            *)
                fatal_error $E_INVALID_ARGUMENT \
                    'Could not understand snapshot selection' \
                    "${use_snapshot[$i]} for config $i" ;;
        esac
        if ((verbose > 0)) && [[ "${use_snapshot[$i]}" ]] ; then
            printf 'Using snapshot %s for config %s\n' \
                "${use_snapshot[$i]}" "$i"
        fi
    done
}

# generate sed script to replace subvolume paths with corresponding snapshots
# (and pool directory, if --pool-dir is specified) and run it on snapraid.conf
generate_temp_snapraid_conf() {
    local data_line match_line new_path sed_find sed_replace i
    local -a sed_exps
    # sed BRE matching data line up to the point where the path starts
    readonly data_line=$'^[ \t]*data[ \t]\{1,\}[^ \t]\{1,\}[ \t]\{1,\}'
    sed_exps=()
    if [[ "$pool_dir" ]] ; then
        # shellcheck disable=SC2016
        # $a is a sed command, not part of a bash variable, so is single quoted
        sed_exps+=( $'/^[ \t]*pool[ \t]\{1,\}/d'
                    '$apool '"$pool_dir" )
    fi
    for i in "${snapper_configs[@]}" ; do
        if [[ "${use_snapshot[$i]}" != 0 ]] ; then
            new_path="${snapper_subvols[$i]}/.snapshots/"
            new_path+="${use_snapshot[$i]}/snapshot"
            if ! is_btrfs_subvolume "$new_path" ; then
                fatal_error $E_SNAPSHOT_NOT_FOUND "Invalid snapshot $new_path"
            elif ! [[ -r "$new_path" ]] ; then
                fatal_error $E_NO_PERMISSION "No read permission for $new_path"
            fi
            # Escape special characters in paths so that they can be
            # passed to sed as literal strings
            sed_find="$(sed 's/[].*$^/\[]/\\&/g' <<< "${snapper_subvols[$i]}")"
            sed_replace="$(sed 's/[&/\]/\\&/g' <<< "$new_path")"
            match_line="$data_line$sed_find"$'[\/]\{0,1\}[\r]\{0,1\}$'
            sed_exps+=( "/$match_line/s/$sed_find/$sed_replace/" )
            # also match the deprecated token 'disk' using separate sed
            # expression to avoid depending on the GNU extension \|
            match_line="${match_line/data/disk}"
            sed_exps+=( "/$match_line/s/$sed_find/$sed_replace/" )
        fi
    done
    if ((${#sed_exps[@]} == 0)) ; then
        cat_builtin "$config_file"
    else
        sed -f <(printf '%s\n' "${sed_exps[@]}") -- "$config_file"
    fi
}

# given the snapraid.conf name for a disk (e.g. d1 in disk d1 /foo/bar),
# find the corresponding snapper config name, if any
get_snapper_config_name() {
    local field1 field2 field3 subvol i
    subvol=
    while IFS=$' \t' read -r field1 field2 field3 ; do
        case $field1 in
            data|disk)
                if [[ "$field2" = "$1" ]] ; then
                    subvol="$field3"
                    break
                fi ;;
        esac
    done < "$config_file"
    [[ "$subvol" ]] || return
    for i in "${snapper_configs[@]}" ; do
        if [[ "${snapper_subvols[$i]}" = "$subvol" ]] ; then
            printf '%s\n' "$i"
            break
        fi
    done
}

interactive_ask() {
    local choice
    printf 'About to run the command:\n'
    printf '%s ' "$@"
    printf '\n'
    while true ; do
        read -r -p 'Do it [Y/N]? ' choice
        case $choice in
            y|Y)
                break ;;
            n|N)
                exit $E_INTERACTIVE_NO ;;
            *)
                printf 'Invalid choice. Please enter y or n.\n' ;;
        esac
    done
}

invalid_argument() {
    fatal_error $E_INVALID_ARGUMENT "Invalid argument $1"
}

# Returns:
# 0 if $1 is a btrfs subvolume
# 1 if $1 is an "empty subvolume" inside a snapshot
# 2 if $1 is an ordinary directory
# 3 if $1 is not a directory
# 4 if we couldn't determine the inode number with stat
is_btrfs_subvolume() {
    [[ -d "$1" ]] || return 3
    case $(stat --format=%i -- "$1") in
        256)
            return 0 ;;
        2)
            return 1 ;;
        '')
            return 4 ;;
        *)
            return 2 ;;
    esac
}

main() {
    check_dependencies awk basename dirname grep mktemp rm sed stat tail
    local config_file debug_fd my_name my_snapper my_snapraid pool_dir \
        snapper_cleanup snapper_description snapper_userdata \
        snapper_userdata_key temp_dir use_snapshot_all_option \
        use_snapshot_option
    local -i interactive use_filter_disk verbose
    local -a no_pre_post_option pre_post_configs pre_post_option \
        rm_on_exit snapper_configs
    local -A pre_snapshot snapper_subvols use_snapshot
    trap 'err_trap $LINENO "$BASH_COMMAND" $?' ERR
    trap 'exit_trap' EXIT
    config_file="${SNAPRAID_CONFIG_FILE:-$DEFAULT_CONFIG_FILE}"
    debug_fd=
    interactive=0
    my_name="$(basename -- "${BASH_SOURCE[0]}")"
    my_snapper=snapper
    my_snapraid=snapraid
    no_pre_post_option=()
    pool_dir=
    pre_post_option=()
    rm_on_exit=()
    snapper_cleanup=
    snapper_configs=()
    snapper_description=
    snapper_userdata_key="${SNAPRAID_USERDATA_KEY:-$DEFAULT_USERDATA_KEY}"
    snapper_userdata="$snapper_userdata_key=created"
    temp_dir="${TMPDIR:-$DEFAULT_TMPDIR}"
    must_be_writable "$temp_dir"
    use_filter_disk=0
    use_snapshot_all_option=
    use_snapshot_option=
    verbose=0
    parse_arguments "$@"
}

# set $snapper_userdata_key userdata key to $1
modify_userdata() {
    local i
    local -i ret snapper_ret
    ret=0
    for i in "${snapper_configs[@]}" ; do
        "$my_snapper" -c "$i" modify -u "$snapper_userdata_key=$1" \
            "${use_snapshot[$i]}" && true
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    return $ret
}

must_be_directory() {
    [[ -d "$1" ]] ||
        fatal_error $E_INVALID_ARGUMENT "$1 is not a directory"
}

must_be_executable() {
    [[ -x "$1" ]] ||
        fatal_error $E_INVALID_ARGUMENT "$1 is not an executable file"
}

must_be_writable() {
    [[ -w "$1" ]] ||
        fatal_error $E_NO_PERMISSION \
            "No write permission for $1 - is TMPDIR set correctly?"
}

# call this to make sure $2 is defined when user specifies option requring it
option_requires_argument() {
    [[ "${2-}" ]] ||
        fatal_error $E_INVALID_ARGUMENT "Option $1 requires an argument"
}

parse_arguments() {
    local opt_str
    local -i length i
    while (($# > 0)) ; do
        case $1 in
            # matching any command means option processing is complete
            check|diff|dup|list|pool|scrub|status|fix|touch) ;&
            cleanup?(-all)|l@(s|ist)|?(diff-|d)sync) ;&
            config|create|resume|rollback|shell|snapper|undochange)
                run_command "$@" ;;
            # snapraid-btrfs options specified before command
            # long form options that don't take arguments
            --@(help|interactive|quiet|verbose|debug|use-filter-disk)?(=*))
                # ignore any argument passed with --opt=arg format
                set_option "${1%%=*}"
                shift ;;
            # long form options that require arguments
            --@(conf|cleanup|description|pool-dir|use-snapshot?(-all))?(=*)) ;&
            --@(?(no-)pre-post|@(snap@(per-@(path|userdata)|raid-path)))?(=*))
                # allow POSIX --argument option or --argument=option formats
                opt_str="${1%%=*}"
                if [[ "$opt_str" = "$1" ]] ; then
                    set_option "$opt_str" "${2-}"
                    shift 2 || shift
                else
                    set_option "$opt_str" "${1#$opt_str=}"
                    shift
                fi ;;
            --*)
                invalid_argument "$1" ;;
            # allow POSIX-style combining of short options
            -*)
                opt_str="${1#-}"
                length="${#opt_str}"
                for ((i=0;i<length;i++)) ; do
                    case ${opt_str:$i:1} in
                        # short options that don't take arguments
                        [hiqvx])
                            set_option "-${opt_str:$i:1}"
                            if ((i == length-1)) ; then
                                shift
                            fi ;;
                        # short options that require arguments
                        [cCduU])
                            if ((i == length-1)) ; then
                                set_option "-${opt_str:$i:1}" "${2-}"
                                shift 2 || shift
                            else
                                set_option "-${opt_str:$i:1}" \
                                    "${opt_str:$((i+1))}"
                                shift
                                break
                            fi ;;
                        *)
                            invalid_argument "-${opt_str:$i:1}" ;;
                    esac
                done ;;
            *)
                invalid_argument "$1" ;;
        esac
    done
    fatal_error $E_INVALID_ARGUMENT "No command specified"
}

# use awk to parse piped snapper ls output and find snapshot numbers
# matching the specified userdata constraints:
# if $1 and $2 are nonempty, match snapshots with userdata key $1=$2
# else if $1 is nonempty, match snapshots with userdata key $1 defined
# else match all snapshots
# if multiple snapshots match, separate their numbers with $3, or
# if $3 is undefined, separate the snapshot numbers with newlines
parse_snapper_ls() {
    awk -F '|' \
        -v key="${1-}" \
        -v value="${2-}" \
        -v ORS="${3:-$'\n'}" \
        -f <(cat_builtin <<'_EOF_'
# first 2 lines are the header
NR<=2 { next }
{
    # remove spaces used to pad column width
    gsub(/[ ]+/,"",$2)
    if (key == "") {
        # match all snapshots
        print $2
    } else {
        # split userdata column into key=value pairs in case
        # multiple userdata keys are defined for a snapshot
        split($8,u,",")
        # construct a new array v where the keys are the values from u
        for (i in u) {
            # remove padding spaces
            gsub(/^[ ]+/,"",u[i])
            gsub(/[ ]+$/,"",u[i])
            if (value == "") {
                # We don't care about the value of the userdata key, so
                # split key=value pairs and store only the key as a key in v
                split(u[i],w,"=")
                v[w[1]]
            } else {
                # We care about both halves of the userdata key=value
                # pair, so store the whole key=value string as a key in v
                v[u[i]]
            }
        }
        # find and print our matches
        if (value == "") {
            if (key in v) {
                print $2
            }
        } else {
            if (key "=" value in v) {
                print $2
            }
        }
        # Wipe v so one match doesn't result in matching all subsequent lines
        # delete v only works in gawk
        split("",v," ")
    }
}
_EOF_
            )
}

# Run the command given in $1
run_command() {
    setup_config
    case $1 in
        # Setup ${use_snapshot[@]}
        cleanup)
            use_snapshot_all sync ;;&
        cleanup-all|touch)
            use_snapshot_all 0 ;;&
        config)
            use_snapshot_default last ;;&
        check|dup|pool|rollback|scrub|status|undochange)
            use_snapshot_default sync ;;&
        create|diff|?(d|diff-)sync)
            use_snapshot_default new ;;&
        fix)
            use_snapshot_fix "$@" ;;&
        resume)
            use_snapshot_default res ;;&
        shell|snapper)
            use_snapshot_default '' ;;&
        !(cleanup-all|l@(s|ist)|snapper|touch))
            find_snapshots "$1" ;;&
        !(cleanup?(-all)|l@(s|ist)|shell|snapper|touch))
            use_snapshot_check ;;&
        # Implementation of commands that don't invoke snapraid
        cleanup?(-all))
            cleanup_snapshots ;;
        config)
            generate_temp_snapraid_conf ;;
        l@(s|ist))
            shift
            snapper_ls "$@" ;;
        rollback)
            snapper_rollback ;;
        shell)
            shift
            do_shell "$@" ;;
        snapper)
            shift
            do_snapper "$@" ;;
        undochange)
            shift
            snapper_undochange "$@" ;;
        # Implementation of commands that invoke snapraid
        check|diff|dup|fix|pool|scrub|status|sync|touch)
            run_snapraid "$@" && true ;;
        resume)
            shift
            run_snapraid sync "$@" && true ;;
        @(d|diff-)sync)
            shift
            local -i diff_ret
            run_snapraid diff "$@" && true
            diff_ret=$?
            # snapraid diff returns 2 if a sync is required
            if ((diff_ret == 2)) ; then
                ((++interactive))
                run_snapraid sync "$@" && true
            else
                exit $diff_ret
            fi ;;
    esac
    exit
}

# Returns exit status of snapraid, postfix calls with '&& true' to avoid
# triggering errexit if snapraid's return status is nonzero
run_snapraid() {
    check_snapraid_arguments "$@"
    local temp_config_file
    local -i ret
    local -a snapraid_cmd
    temp_config_file="$(mktemp -- "$temp_dir/$my_name.XXXXXX")"
    rm_on_exit+=( "$temp_config_file" )
    must_be_writable "$temp_config_file"
    generate_temp_snapraid_conf > "$temp_config_file"
    snapraid_cmd=( "$my_snapraid" -c "$temp_config_file" "$@" )
    if ((verbose >= 0)) ; then
        printf 'Using snapraid config file:\n'
        cat_builtin "$temp_config_file"
    fi
    verbose_command "${snapraid_cmd[@]}"
    case $1 in
        fix|touch)
            create_pre_post_snapshots "$1" ;;
        sync)
            modify_userdata syncing
            # set up a trap to track whether snapraid sync returned exit status
            # 0 because it completed successfully, or because it was
            # interrupted with ctrl-C, but was able to clean up before exiting
            local -i interrupted
            interrupted=0
            trap '((++interrupted)) ; trap - INT TERM QUIT' INT TERM QUIT ;;
    esac
    # Run snapraid
    "${snapraid_cmd[@]}" && true
    ret=$?
    case $1 in
        fix|touch)
            create_pre_post_snapshots "$1" ;;
        diff)
            # snapraid diff returns 0 if no changes, 2 if sync needed
            if ((ret == 0)) || ((ret == 2)) ; then
                modify_userdata "$1"
            fi ;;
        sync)
            trap - INT TERM QUIT
            # don't mark sync as completed if INT/TERM/QUIT trap was triggered
            if ((ret == 0)) && ((interrupted == 0)) ; then
                modify_userdata synced
            fi ;;
    esac
    return $ret
}

# $1 is option being set, $2 is argument. If no argument,
# $2 can be either undefined or empty
set_option() {
    case $1 in
        --@(conf|cleanup|description|pool-dir|use-snapshot?(-all))) ;&
        --@(?(no-)pre-post|@(snap@(per-@(path|userdata)|raid-path)))) ;&
        -[cCduU])
            option_requires_argument "$@" ;;&
        -c|--conf)
            config_file="$2" ;;
        -C|--cleanup)
            snapper_cleanup="$2" ;;
        -d|--description)
            snapper_description="$2" ;;
        -h|--help)
            usage
            exit ;;
        -i|--interactive)
            ((++interactive)) ;;
        -q|--quiet)
            ((--verbose)) ;;
        -u|--use-snapshot-all)
            use_snapshot_all_option="$2" ;;
        -U|--use-snapshot)
            use_snapshot_option="$2" ;;
        -v|--verbose)
            ((++verbose)) ;;
        -x|--debug)
            enable_debug_mode ;;
        --no-pre-post)
            IFS=',' read -r -a no_pre_post_option <<< "$2" ;;
        --pool-dir)
            must_be_directory "$2"
            pool_dir="$2" ;;
        --pre-post)
            IFS=',' read -r -a pre_post_option <<< "$2" ;;
        --snapper-path)
            must_be_executable "$2"
            my_snapper="$2" ;;
        --snapper-userdata)
            use_snapper_userdata "$2" ;;
        --snapraid-path)
            must_be_executable "$2"
            my_snapraid="$2" ;;
        --use-filter-disk)
            ((++use_filter_disk)) ;;
        *)
            invalid_argument "$1" ;;
    esac
}

# Called immediately after all command line options have been parsed to
# read snapraid configuration file and initialize the arrays local to main()
# which track the configuration
setup_config() {
    check_dependencies "$my_snapper" "$my_snapraid"
    check_config_file
    find_configs
    check_config
    [[ "$use_snapshot_option" ]] &&
        apply_use_snapshot_option "$use_snapshot_option"
    local i
    if [[ "$use_snapshot_all_option" ]] ; then
        for i in "${snapper_configs[@]}" ; do
            [[ "${use_snapshot[$i]-}" ]] ||
                use_snapshot[$i]="$use_snapshot_all_option"
        done
    fi
    apply_pre_post_options
}

# Do a snapper ls in all configs, and if argument is specified, additionally
# identify which snapshots we found with userdata $snapper_userdata_key=$*
snapper_ls() {
    local i
    for i in "${snapper_configs[@]}" ; do
        printf '\n%s %s\n' "$i" "${snapper_subvols[$i]}"
        "$my_snapper" -c "$i" ls
        if (($# > 0)) ; then
            printf 'Snapshots with userdata key %s=%s:\n' \
                "$snapper_userdata_key" "$*"
            "$my_snapper" -c "$i" ls |
                parse_snapper_ls "$snapper_userdata_key" "$*" ' '
            printf '\n'
        fi
    done
    printf '\n'
}

# Run snapper rollback in each snapper config
snapper_rollback() {
    local i
    local -i ret snapper_ret
    local -a snapper_cmd snapper_rollback_opts
    ret=0
    snapper_rollback_opts=( -u "$snapper_userdata" )
    [[ "$snapper_cleanup" ]] ||
        snapper_rollback_opts+=( -c "$snapper_cleanup" )
    if [[ "$snapper_description" ]] ; then
        snapper_rollback_opts+=( -d "$snapper_description" )
    else
        snapper_rollback_opts+=( -d "$my_name rollback" )
    fi
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        snapper_cmd=( "$my_snapper" -c "$i" rollback
                      "${snapper_rollback_opts[@]}" "${use_snapshot[$i]}" )
        verbose_command "${snapper_cmd[@]}"
        "${snapper_cmd[@]}" && true
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    return $ret
}

# Run snapper undochange in each snapper config to revert to the state at the
# time ${use_snapshot[$i]} was created, creating before and after snapshots
snapper_undochange() {
    local i
    local -i ret snapper_ret
    local -a snapper_cmd undochange_files undochange_opts
    ret=0
    undochange_files=()
    undochange_opts=()
    create_pre_post_snapshots undochange
    # ensure that -i option, if specified, appears before snapshots
    # and any other arguments specified (except --) appear after snapshots
    while (($# > 0)) ; do
        case $1 in
            --)
                shift
                break ;;
            -i|--input)
                if (($# > 1)) ; then
                    undochange_opts+=( "$1" "$2" )
                    shift 2
                else
                    undochange_files+=( "$1" )
                    shift
                fi ;;
            *)
                undochange_files+=( "$1" )
                shift ;;
        esac
    done
    undochange_files+=( "$@" )
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" = 0 ]] && continue
        snapper_cmd=( "$my_snapper" -c "$i" undochange "${undochange_opts[@]}"
                      "${use_snapshot[$i]}..0" -- "${undochange_files[@]}" )
        verbose_command "${snapper_cmd[@]}"
        "${snapper_cmd[@]}" && true
        snapper_ret=$?
        if ((snapper_ret != 0)) ; then
            ret=$snapper_ret
        fi
    done
    create_pre_post_snapshots undochange
    return $ret
}

# returns 0 if $2 is an argument to $1, and 1 if not
snapraid_opt_has_arg() {
    if (($# < 2)) ; then
        return 1
    fi
    case $1 in
        # snapraid long-form options that require arguments
        --@(filter?(-disk)|percentage)) ;&
        --@(import|plan|older-than|log|start|count|error-limit|gen-conf)) ;&
        # snapraid short-form options that require arguments
        -*(["$SNAPRAID_OPTS_NOARG"])["$SNAPRAID_OPTS_ARG"])
            return 0 ;;
    esac
    return 1
}

# if snapshot not found for a config, prompt the user to choose a different one
snapshot_not_found() {
    local choice snapshot_list
    printf '%s: Snapshot not found for config %s at %s\n' "$my_name" "$1" \
        "${snapper_subvols[$1]}"
    if ((verbose < 0)) ; then
        exit $E_SNAPSHOT_NOT_FOUND
    else
        snapshot_list="$("$my_snapper" -c "$1" ls)"
        printf '%s\n' "$snapshot_list"
    fi
    while true ; do
        read -r -p 'Enter a snapshot (0 for none, n for new, q to quit): ' \
            choice
        case $choice in
            q)
                exit $E_INTERACTIVE_NO ;;
            n)
                use_snapshot[$1]=new
                find_snapshots 'interactive prompt'
                break ;;
            +([[:digit:]]))
                if [[ "$choice" = 0 ]] ||
                       { parse_snapper_ls <<< "$snapshot_list" |
                             grep -Fx "$choice" > /dev/null ; }
                then
                    use_snapshot[$1]="$choice"
                    break
                else
                    printf 'Snapshot %s not found\n' "$choice"
                fi ;;
            *)
                printf 'Invalid selection %s\n' "$choice" ;;
        esac
    done
} >&2

usage() {
    local bold reset
    readonly bold=$'\e[1m'
    readonly reset=$'\e[0m'
    cat_builtin <<_EOF_
${bold}Usage: $my_name [options] <command> [arguments]${reset}

Arguments appearing after the command are passed through to snapraid, while
the following options appearing before the command are interpreted by
$my_name:
  -h, --help                    Show this help
  -c, --conf FILE               Specify location of snapraid config file
                                (default /etc/snapraid.conf)
  -C, --cleanup STR             Specify snapper cleanup algorithm to set for any
                                snapshots created (default none)
  -d, --description STR         Specify snapper description to set for any
                                snapshots created
  -i, --interactive             Ask before running snapraid or any potentially
                                destructive snapper commands (when using the
                                cleanup(-all), rollback, or undochange commands)
  -q, --quiet                   Only show snapraid/snapper output and errors
  -u, --use-snapshot-all STR    Use one of the following arguments:
                                    diff - Use last snapshot a diff was
                                           completed with
                                    last - Use last snapshots created
                                    new  - Create new snapshots
                                    res  - Resume using snapshots from an
                                           interrupted sync
                                    sync - Use last snapshots a successful sync
                                           was completed with
                                or specify the snapshot number (0 for the live
                                filesystem, following snapper syntax)
                                Default is:
                                    'new' for diff|dsync|sync
                                    'last' for config
                                    'res' for resume
                                    'sync' for all other readonly commands
  -U, --use-snapshot STR        Specify snapshots to use for specific snapper
                                configurations, using the snapper config name
                                followed by an equals sign. Multiple
                                configurations should be separated by commas,
                                e.g. 'config1=5,config2=last'. Overrides -u
  -v, --verbose                 Increase verbosity of output
  -x, --debug                   Enable debugging output
  --no-pre-post STR             Don't create pre/post snapshots for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
  --pool-dir DIR                Create pool symlinks in DIR (defaults to
                                directory specified in snapraid config file)
  --pre-post STR                Create pre/post snapshots only for the
                                specified snapper configuration(s). Multiple
                                configurations should be separated by commas.
  --snapper-path PATH           Path to the snapper executable (defaults to
                                first found in \$PATH)
  --snapper-userdata STR        Specify snapper userdata to set for any
                                snapshots created in addition to the
                                $my_name attribute, which is set by
                                default and cannot be changed. Argument should
                                be in key=value format accepted by snapper,
                                with multiple keys separated by commas (e.g.
                                key1=value1,key2=value2)
  --snapraid-path PATH          Path to the snapraid executable (defaults to
                                first found in \$PATH)
  --use-filter-disk             If running a fix with the snapraid -d/
                                --filter-disk option, use the live filesystem
                                by default for all disks specified as arguments
                                to the --filter-disk option, and the last
                                synced snapshot for all disks not so specified.

  NOTE: The snapraid -c/--conf option will not work unless placed before the
  command, allowing it to be interpreted as a $my_name option. Snapraid will be
  run with a temporary configuration file, generated using whatever
  snapraid.conf file is specified using the $my_name -c/--conf option
  ($DEFAULT_CONFIG_FILE by default).

${bold}Commands are either one of the following snapraid commands:${reset}
  'check'|'diff'|'dup'|'pool'|'scrub'|'status'|'sync':
        Run the snapraid command given, replacing data drives in snapraid config
        file that have corresponding snapper configs with read-only snapshots.
  'fix'|'touch':
        Run the snapraid command given, creating a set of pre/post snapshots
        before and after (for fix, if the snapraid -d/--filter-disk option is
        specified, create pre/post snapshots only for the specified disk(s),
        and use the last-synced snapshot for the rest).

${bold}or one of the following $my_name specific commands:${reset}
  'config':
        Show the modified snapraid config file that would be used, but don't
        actually run snapraid.
  'create':
        Create a new snapshot for all snapper configs corresponding to data
        drives found in snapraid config file.
  'cleanup':
        Delete all snapshots created by $my_name except the last one a
        successful sync has been completed with.
  'cleanup-all':
        Delete all snapshots created by $my_name.
  'dsync'|'diff-sync':
        Create a new snapshot for all snapper configs found in snapraid config
        file, do a snapraid diff, then sync. Implies --interactive option for
        the sync operation.
  'list'|'ls':
        Run snapper ls for all snapper configs found in snapraid config file.
        If an argument is given, also list which snapshots in each config were
        identified as having snapper userdata key equal to the argument.
  'resume':
        Resume an interrupted sync, using the same set of snapshots.
  'rollback':
        Run snapper rollback in all snapper configs using the snapshots from
        the last successful sync (or another snapshot if the -u or -U option
        is specified). WARNING: Do not use this command unless you are familiar
        with the snapper rollback command and its effects. Instead consider
        using the undochange command.
  'snapper':
        Run the given snapper command in all configs, unless they are disabled
        by --use-snapshot exampleconfig=0 - for example:
           $my_name -U foo=0 snapper get-config
        would run
           snapper -c "\$i" get-config
        substituting "\$i" for each snapper config matching the snapraid.conf
        file, except foo.
  'undochange':
        Use snapper undochange to revert the array to the state it was in at
        the time of the last successful sync (or another snapshot if the -u or
        -U option is specified), creating pre/post snapshots. Arguments are
        passed through to snapper undochange, including the snapper undochange
        -i option.

${bold}Environment variables:${reset}
  SNAPRAID_CONFIG_FILE -
        Default location of the snapraid.conf file if -c/--conf option is not
        used. If unset, it defaults to $DEFAULT_CONFIG_FILE.
  SNAPRAID_USERDATA_KEY -
        Snapper userdata key that is used to track snapshots. If unset, it
        defaults to $DEFAULT_USERDATA_KEY.
  TMPDIR -
        Directory to create temporary snapraid.conf file in. If unset, it
        defaults to $DEFAULT_TMPDIR.

_EOF_
}

# Add key/value pairs from $1 to snapper_userdata, unless key is
# $snapper_userdata_key
use_snapper_userdata() {
    local key value i
    local -a args
    IFS=',' read -r -a args <<< "$1"
    for i in "${args[@]}" ; do
        IFS='=' read -r key value <<< "$i"
        [[ "$key" = "$snapper_userdata_key" ]] ||
            snapper_userdata+=",$key=$value"
    done
}

# Set use_snapshot to $1 for all configs, overriding any previous values
use_snapshot_all() {
    local i
    for i in "${snapper_configs[@]}" ; do
        use_snapshot[$i]="$1"
    done
}

# If use_snapshot[$i] is the empty string for any snapper config, indicating
# that find_snapshots did not find a match, handle the error
use_snapshot_check() {
    local i
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]}" ]] || snapshot_not_found "$i"
    done
}

# For any configs where use_snapshot is undefined, set it to $1
use_snapshot_default() {
    local i
    for i in "${snapper_configs[@]}" ; do
        [[ "${use_snapshot[$i]-}" ]] ||
            use_snapshot[$i]="$1"
    done
}

# When running a fix operation, parse the -d/--filter-disk snapraid option if
# specified, and set ${use_snapshot[@]} accordingly
use_snapshot_fix() {
    if ((use_filter_disk == 0)) ; then
        use_snapshot_default 0
        return
    fi
    local disk opt_str snapper_config_name
    local -i configs_found length i
    configs_found=0
    while (($# > 0)) ; do
        disk=
        case $1 in
            --filter-disk=*)
                disk="${1#--filter-disk=}" ;;
            --filter-disk|-*(["$SNAPRAID_OPTS_NOARG"])d)
                option_requires_argument "$@"
                disk="$2" ;;
            -!(-)*)
                opt_str="${1#-}"
                length="${#opt_str}"
                for ((i=0;i<length;i++)) ; do
                    case ${opt_str:$i:1} in
                        d)
                            disk="${opt_str:$((i+1))}" ;&
                        ["$SNAPRAID_OPTS_ARG"])
                            break ;;
                    esac
                done ;;
        esac
        if snapraid_opt_has_arg "$@" ; then
            shift 2
        else
            shift
        fi
        if [[ "$disk" ]] ; then
            snapper_config_name="$(get_snapper_config_name "$disk")"
            if [[ "$snapper_config_name" ]] ; then
                ((++configs_found))
                [[ "${use_snapshot[$snapper_config_name]-}" ]] ||
                    use_snapshot[$snapper_config_name]=0
            fi
        fi
    done
    if ((configs_found > 0)) ; then
        use_snapshot_default sync
        find_snapshots fix
    fi
    use_snapshot_default 0
}

verbose_command() {
    if ((interactive > 0)) ; then
        interactive_ask "$@" >&2
    elif ((verbose >= 0)) ; then
        printf '%s ' "$@"
        printf '\n'
    fi
}

main "$@"
